{
  "task": "get_pos_pairs_similarity",
  "num_pairs_per_case": 10,
  "seed": 42,
  "results": [
    {
      "case": "p03326",
      "src": {
        "code": "n, m = map(int, input().split())\nxyz = [tuple(map(int, input().split())) for _ in range(n)]\nans = 0\nfrom itertools import product\nfor p in product([-1, 1], repeat=3):\n    xyz_ = map(lambda l: l[0]*p[0] + l[1]*p[1] + l[2]*p[2], xyz)\n    xyz_ = sorted(xyz_, reverse=True)\n    ans = max(ans, sum(xyz_[:m]))\nprint(ans)\n",
        "language": "python"
      },
      "dst": {
        "code": "from itertools import product\nN, M = map(int, input().split())\ncake = [list(map(int, input().split())) for i in range(N)]\n\nans = 0\nfor x, y, z in product((1, -1), repeat=3):\n    S = []\n    for a, b, c in cake:\n        S.append(a*x + b*y + c*z)\n    S.sort(reverse=True)\n    ans = max(ans, sum(S[:M]))\n\nprint(ans)\n",
        "language": "python"
      },
      "similarity": {
        "bleu": 0.4431187662051977,
        "jaccard": 0.5614035087719298,
        "tsed": 0.6544000000000001,
        "cged": 0.5960264900662251,
        "codebleu": 0.3341709542116901
      }
    },
    {
      "case": "p03326",
      "src": {
        "code": "N, M = map(int, input().split())\nList = [list(map(int, input().split())) for _ in range(N)]\n\nfrom itertools import product\n\nans = 0\nfor a, b, c in product([1, -1], repeat=3):\n    tmp = []\n    for x, y, z in List:\n        tmp.append(a*x+b*y+c*z)\n    tmp.sort(reverse=True)\n    ans = max(ans, sum(tmp[:M]))\n    \nprint(ans)",
        "language": "python"
      },
      "dst": {
        "code": "n,m=map(int,input().split())\nx=[];y=[];z=[]\nfor i in range(n):\n  a,b,c=map(int,input().split())\n  x.append(a);y.append(b);z.append(c)\nmx=0\nfor i in [-1,1]:\n  for j in [-1,1]:\n    for k in [-1,1]:\n      s=[]\n      for l in range(n):\n        s.append(i*x[l]+j*y[l]+k*z[l])\n      s.sort()\n      s.reverse()\n      d=abs(sum(s[0:m]))\n      if d>mx:\n        mx=d\nprint(mx)\n  ",
        "language": "python"
      },
      "similarity": {
        "bleu": 0.22612531655518078,
        "jaccard": 0.5254237288135594,
        "tsed": 0.5630057803468214,
        "cged": 0.6936026936026936,
        "codebleu": 0.23433056737557698
      }
    },
    {
      "case": "p03326",
      "src": {
        "code": "n,m=map(int,input().split())\nxyz=[list(map(int,input().split())) for i in range(n)]\nans=[]\nfor i in [-1,1]:\n    for j in [-1,1]:\n        for k in [-1,1]:\n            ans.append(sum(sorted([i*l[0]+j*l[1]+k*l[2] for l in xyz],reverse=True)[:m]))\nprint(max(ans))",
        "language": "python"
      },
      "dst": {
        "code": "N,M=map(int,input().split())\nxyz=[list(map(int,input().split()))for i in range(N)]\nans=0\nfor i in range(8):\n    i=bin(i)[2:].zfill(3)\n    k=[]\n    for j in range(3):\n        if i[j]==\"0\":\n            k.append(1)\n        else:\n            k.append(-1)\n    l=[k[0]*x+k[1]*y+k[2]*z for x,y,z in xyz]\n    l.sort(reverse=True)\n    ans=max(ans,sum(l[:M]))\nprint(ans)\n",
        "language": "python"
      },
      "similarity": {
        "bleu": 0.3778036134559484,
        "jaccard": 0.6938775510204082,
        "tsed": 0.4962500000000006,
        "cged": 0.7008,
        "codebleu": 0.24511178788613744
      }
    },
    {
      "case": "p03326",
      "src": {
        "code": "from operator import itemgetter\n\nn, m = map(int, input().split())\ncake = []\nfor i in range(n):\n    x, y, z = map(int, input().split())\n    cake.append([x + y + z, x + y - z, x - y + z, x - y - z,\n                 -x + y + z, -x + y - z, -x - y + z, -x - y - z])\nif m == 0:\n    print(0)\nelse:\n    print(max([sum(a[-m:]) for a in list(map(sorted, list(zip(*cake))))]))",
        "language": "python"
      },
      "dst": {
        "code": "N,M=map(int,input().split())\nxyz=[]\nfor i in range(N):\n    xyz.append(list(map(int,input().split())))\ncoefs=[[1,1,1],[1,1,-1],[1,-1,1],[1,-1,-1]\n       ,[-1,1,1],[-1,1,-1],[-1,-1,1],[-1,-1,-1]]\nans=[]\n\nfor ix,iy,iz in coefs:\n    xyz_ = [sum([ix*l[0],iy*l[1],iz*l[2]]) for l in xyz]\n    ans.append(sum(sorted(xyz_,reverse=True)[:M]))\nprint(max(ans))",
        "language": "python"
      },
      "similarity": {
        "bleu": 0.23288804373724906,
        "jaccard": 0.46296296296296297,
        "tsed": 0.28500000000000003,
        "cged": 0.47404844290657444,
        "codebleu": 0.18286613005536345
      }
    },
    {
      "case": "p03326",
      "src": {
        "code": "from itertools import product\nN, M = map(int, input().split())\nx, y, z = zip(*(map(int, input().split()) for _ in range(N)))\n\n\ndef f(a, b, c):\n    return sum(sorted(map(sum, zip(a, b, c)), reverse=True)[:M])\n\n\ndef g(k, a):\n    return [k * e for e in a]\n\n\nans = max(\n    f(g(p, x), g(q, y), g(r, z))\n    for p, q, r in product((-1, 1), repeat=3)\n)\nprint(ans)\n",
        "language": "python"
      },
      "dst": {
        "code": "N,M=map(int,input().split())\nxyz=[]\nfor i in range(N):\n    xyz.append(list(map(int,input().split())))\ncoefs=[[1,1,1],[1,1,-1],[1,-1,1],[1,-1,-1]\n       ,[-1,1,1],[-1,1,-1],[-1,-1,1],[-1,-1,-1]]\nans=[]\n\nfor ix,iy,iz in coefs:\n    xyz_ = [sum([ix*l[0],iy*l[1],iz*l[2]]) for l in xyz]\n    ans.append(sum(sorted(xyz_,reverse=True)[:M]))\nprint(max(ans))",
        "language": "python"
      },
      "similarity": {
        "bleu": 0.27064933869347885,
        "jaccard": 0.43548387096774194,
        "tsed": 0.24625000000000039,
        "cged": 0.3972602739726028,
        "codebleu": 0.19751210092726237
      }
    },
    {
      "case": "p03326",
      "src": {
        "code": "n, m = map(int, input().split())\n\nr = [[0]*n for _ in range(8)]\nfor i in range(n):\n    x, y, z = map(int, input().split())\n    r[0][i] = x+y+z\n    r[1][i] = x+y-z\n    r[2][i] = x-y+z\n    r[3][i] = x-y-z\n    r[4][i] = -x+y+z\n    r[5][i] = -x+y-z\n    r[6][i] = -x-y+z\n    r[7][i] = -x-y-z\n\nprint(max(sum(sorted(r[i])[-m:]) for i in range(8)) if m != 0 else 0)\n",
        "language": "python"
      },
      "dst": {
        "code": "n,m = map(int,input().split())\nxyz = [list(map(int,input().split())) for _ in range(n)]\nres = 0\nfor a in (1,-1):\n    for b in (1,-1):\n        for c in (1,-1):\n            l = []\n            for (x,y,z) in xyz:\n                l.append(x*a+y*b+z*c)\n            l = sorted(l,reverse=True)\n            res = max(res, sum(l[:m]))\nprint(res)\n",
        "language": "python"
      },
      "similarity": {
        "bleu": 0.22207927775733058,
        "jaccard": 0.5769230769230769,
        "tsed": 0.2946236559139789,
        "cged": 0.5584218512898331,
        "codebleu": 0.18253582014412548
      }
    },
    {
      "case": "p03326",
      "src": {
        "code": "from itertools import product\nt=[]\nans=0\nn,m=map(int,input().split())\ns=list(product([1,-1],repeat=3))\nfor i in range(n):\n    li=[]\n    p,q,r=map(int,input().split())\n    for a,b,c in s:\n        li.append(a*p+b*q+c*r)\n    t+=[li]\nfor j in list(zip(*t)):\n    p=sum(sorted(j)[n-m:])\n    ans=max(ans,p)\nprint(ans)\n",
        "language": "python"
      },
      "dst": {
        "code": "n,m=map(int,input().split())\nxyz=[list(map(int,input().split())) for i in range(n)]\n\nans=0\nfor i in [-1,1]:\n  for j in [-1,1]:\n    for k in [-1,1]:\n      l=[]\n      for x,y,z in xyz:\n        l.append(i*x+j*y+k*z)\n      l.sort(reverse=True)\n      ans=max(ans,sum(l[:m]))\nprint(ans)",
        "language": "python"
      },
      "similarity": {
        "bleu": 0.3864098443710361,
        "jaccard": 0.5357142857142857,
        "tsed": 0.4183098591549299,
        "cged": 0.6505190311418685,
        "codebleu": 0.29734016713206546
      }
    },
    {
      "case": "p03326",
      "src": {
        "code": "from itertools import product\nN, M = map(int, input().split())\nCake = [list(map(int, input().split())) for i in range(N)]\n\n\nans = 0\nfor a, b, c in product([-1, 1], repeat=3):\n    score = []\n    for x, y, z in Cake:\n        score.append(a * x + b * y + c * z)\n    score.sort(reverse=True)\n    ans = max(ans, sum(score[:M]))\n\nprint(ans)\n",
        "language": "python"
      },
      "dst": {
        "code": "N, M = map(int, input().split())\nXYZs = [list(map(int, input().split())) for _ in range(N)]\n\nans = 0\nfor op in range(1 << 3):\n    lst = []\n    for xyz in XYZs:\n        v = 0\n        for j in range(3):\n            v += xyz[j] * ((-1) ** ((op >> j) & 1))\n        lst.append(v)\n    ans = max(ans, sum(sorted(lst, reverse=True)[:M]))\n\nprint(ans)",
        "language": "python"
      },
      "similarity": {
        "bleu": 0.4972358376362221,
        "jaccard": 0.543859649122807,
        "tsed": 0.6419354838709677,
        "cged": 0.6297709923664122,
        "codebleu": 0.3499076859383233
      }
    },
    {
      "case": "p03326",
      "src": {
        "code": "from itertools import product\nN, M = map(int, input().split())\ncake = [list(map(int, input().split())) for i in range(N)]\n\nans = 0\nfor x, y, z in product((1, -1), repeat=3):\n    S = []\n    for a, b, c in cake:\n        S.append(a*x + b*y + c*z)\n    S.sort(reverse=True)\n    ans = max(ans, sum(S[:M]))\n\nprint(ans)\n",
        "language": "python"
      },
      "dst": {
        "code": "n,m = map(int, input().split())\nl = []\nfor _ in range(n):\n    l.append([int(x) for x in input().split()])\n\nans = 0\nfor i in range(2):\n    for j in range(2):\n        for k in range(2):\n            a,b,c = (-1)**i, (-1)**j, (-1)**k\n            tmp = [x[0]*a+x[1]*b+x[2]*c for x in l]\n            tmp.sort(reverse=True)\n            ans = max(ans, sum(tmp[:m]))\n\nprint(ans)",
        "language": "python"
      },
      "similarity": {
        "bleu": 0.34715273594449597,
        "jaccard": 0.6111111111111112,
        "tsed": 0.5170068027210886,
        "cged": 0.6430868167202572,
        "codebleu": 0.2926005618664239
      }
    },
    {
      "case": "p03326",
      "src": {
        "code": "[N, M] = map(int, input().split())\na = eval('input().split(),'*N)\nprint(0 if M==0 else max([sum(sorted([sum([int(x[b])*(s>>b&1or-1)for b in range(3)]) for x in a])[-M:])for s in range(8)]))",
        "language": "python"
      },
      "dst": {
        "code": "from itertools import product\nN,M=map(int, input().split())\ninlist=[list(map(int, input().split())) for _ in range(N)]\nres=0\nfor i,j,k in product([1, -1],[1, -1],[1, -1]): res = max(res, sum(sorted(map(lambda x: i*x[0]+j*x[1]+k*x[2], inlist), reverse=True)[:M]))\nprint(res)\n",
        "language": "python"
      },
      "similarity": {
        "bleu": 0.2375291612375307,
        "jaccard": 0.49056603773584906,
        "tsed": 0.4100840336134456,
        "cged": 0.5381165919282511,
        "codebleu": 0.12383331558705915
      }
    },
    {
      "case": "760_B",
      "src": {
        "code": "n, m, k = map(int, input().split())\nl = 1\nr = m + 1\nleft = k - 1\nright = n - k\nrs = right * (right - 1) // 2\nls = left * (left - 1) // 2\nwhile (r > l + 1):\n    md = (l + r) // 2\n    if md > right:\n        s = md - right\n        tr = s * right + rs\n    else:\n        tr = right - md + 1 + md * (md - 1) // 2\n    if md > left:\n        s = md - left\n        lr = s * left + ls\n    else:\n        lr = left - md + 1 + md * (md - 1) // 2\n    if m >= lr + tr + md:\n        l = md\n    else:\n        r = md\nprint(l)",
        "language": "python"
      },
      "dst": {
        "code": "def bin_search(l, r, func):\n    while l < r:\n        c = (l + r) // 2\n        val = func(c)\n\n        if l + 1 == r:\n            if func(r):\n                return r\n            if func(l):\n                return l\n\n        if val:\n            l = c\n        else:\n            r = c - 1\n        # print('l: %s, r: %s' % (l, r))\n    if l == r:\n        return l\n    else:\n        return 1\n\ndef solve(n, m, k):\n    hr, hl = k-1, n-k\n    s_one_n = lambda n: n * (1.0 + n) / 2.0\n    def s_n_m(n, m):\n        return (m-n+1) * (n+m) / 2.0\n    def snm(n, m):\n        return s_one_n(max(n,m)) - s_one_n(min(n,m)-1)\n    def calc_side(ft, hs):\n        if hs == 0:\n            return 0\n        return s_n_m(max(1, ft - hs), ft - 1) + max(0, hs - ft + 1)\n    f = lambda x: calc_side(x, hl) + calc_side(x, hr) + x <= m\n    print(bin_search(1, m*3, f))\n\nn,m,k = map(int, input().split(' '))\nsolve(n,m,k)",
        "language": "python"
      },
      "similarity": {
        "bleu": 0.13746554945657877,
        "jaccard": 0.4406779661016949,
        "tsed": 0.31718749999999984,
        "cged": 0.22274881516587675,
        "codebleu": 0.1629061930114213
      }
    },
    {
      "case": "760_B",
      "src": {
        "code": "n, m, k = map(int, input().split(' '))\n\ndef met(x,n,k):\n    k-=1\n    r = n - k;\n    k = min(k,x-1)\n    r = min(r,x)\n    return ((2*x - k -1)*k//2) + (((2*x - r + 1)*(r))//2)\ndef busqueda_binaria(l, r):\n    if l > r:\n        return r\n    mitad = (l + r) //2\n    if met(mitad,n,k) <= m:\n        return busqueda_binaria(mitad + 1,r)\n    return busqueda_binaria(l,  mitad - 1)\nsol = 1;\nm = m-n\nsol += busqueda_binaria(0,1000000001)\nprint(sol)\n",
        "language": "python"
      },
      "dst": {
        "code": "import sys\n\ndef sum_(a):\n    return max(0, a * (a + 1) // 2)\n\ndef check(a):\n    if a * n <= m:\n        return 1\n    a -= 1\n    ans = n\n    t1 = a - k + 1\n    #print(a)\n    if t1 >= 0:\n        ans += sum_(a) - sum_(t1 - 1)\n    else:\n        ans += sum_(a)\n    #print(ans)\n    z = n - k + 1\n    t2 = a - z + 1\n    #print('ts', t2)\n    if t2 >= 0:\n        ans += sum_(a - 1) - sum_(t2 - 1)\n    else:\n        ans += sum_(a - 1)\n    #print(ans)\n    return (ans <= m)\n\ndef bins():\n    l = 1\n    r = m + 1\n    while l + 1 != r:\n        m1 = (l + r) // 2\n        if check(m1):\n            l = m1\n        else:\n            r = m1\n    print(l)\n    \nn, m, k = map(int, input().split())\n#print(check(2))\nbins()\n\n            \n",
        "language": "python"
      },
      "similarity": {
        "bleu": 0.23075871907789616,
        "jaccard": 0.5283018867924528,
        "tsed": 0.325714285714286,
        "cged": 0.3609958506224067,
        "codebleu": 0.16700739799681463
      }
    },
    {
      "case": "760_B",
      "src": {
        "code": "n, m, k = map(int, input().split())\nm -= n\nd = 0\nk -= 1\nans = 1\nwhile m > 1 and d != max(k, n - k - 1):\n    ans += 1\n    m -= 1\n    l = min(d, k)\n    r = min(d, n - k - 1)\n    d += 1\n    m -= l\n    m -= r\nans += m // n\n\nprint(ans)",
        "language": "python"
      },
      "dst": {
        "code": "n,m,k= map(int,input().split())\ndef calc(x,n,k):\n    k-=1\n    r = n - k;\n    k = min(k,x-1)\n    r = min(r,x)\n    return ((2*x - k -1)*k//2) + (((2*x - r + 1)*(r))//2)\ndef bsearch(l, r):\n    if l > r:\n        return r\n    mid = (l + r) //2\n    if calc(mid,n,k) <= m:\n        return bsearch(mid + 1,r)\n    return bsearch(l, mid - 1)\nfrod = 1;\nm -= n\nfrod += bsearch(0,1000000001)\nprint(frod)\n",
        "language": "python"
      },
      "similarity": {
        "bleu": 0.20156931099080921,
        "jaccard": 0.5476190476190477,
        "tsed": 0.5013157894736845,
        "cged": 0.33618233618233617,
        "codebleu": 0.21385830730027774
      }
    },
    {
      "case": "760_B",
      "src": {
        "code": "n, m, k = list(map(int, input().split()))\nleft = 0\nright = 10000000000\nwhile (right - left > 1):\n    mid = (left + right) // 2\n    counter = mid\n    lh = k - 1\n    if lh >= mid - 1:\n        counter += (mid - 1) * mid // 2\n        counter += lh - (mid - 1)\n    else:\n        last_hobbit = mid - lh - 1\n        counter += (mid - 1) * mid // 2 - (last_hobbit) * (last_hobbit + 1) // 2\n    rh = n - k\n    if rh >= mid - 1:\n        counter += (mid - 1) * mid // 2\n        counter += rh - (mid - 1)\n    else:\n        last_hobbit = mid - rh - 1\n        counter += (mid - 1) * mid // 2 - (last_hobbit) * (last_hobbit + 1) // 2    \n    if counter > m:\n        right = mid\n    else:\n        left = mid\nprint(left)\n    \n        ",
        "language": "python"
      },
      "dst": {
        "code": "n,m,k = map(int, input().split())\n\na = 0\nb = 0\n\na_lim = k-1\nb_lim = n-k\nm = m-n\nx = 1\n\nwhile m-a-b-1 >= 0:\n    m = m-a-b-1\n    x += 1\n\n    if a != a_lim:\n        a += 1\n\n    if b != b_lim:\n        b += 1\n\n    if a == a_lim and b == b_lim:\n        x = x + m//n\n        break\n        \nprint(x)\n\n    \n",
        "language": "python"
      },
      "similarity": {
        "bleu": 0.13504834152618822,
        "jaccard": 0.5238095238095238,
        "tsed": 0.4212121212121213,
        "cged": 0.4,
        "codebleu": 0.20953343085152684
      }
    },
    {
      "case": "760_B",
      "src": {
        "code": "n , k , my = map( int , input().split() )\n\ndef distribute( l,r,c ):\n    if l > r :\n        return 0\n    x = r-l+1;\n    if x > c :\n        x = c\n    return ( (x*(x+1))//2 ) + ((c-x)*x)\n\ndef givable( cc ):\n    return distribute( 1 , my-1 , cc-1 ) + distribute( my+1, n , cc-1 ) + cc <= k\n\nAns = 1\nk = k - n\n\nhigh, low, mid , additional = ( k , 0 , -1 , 0 )\nwhile( low <= high ) :\n    mid = (high + low)//2;\n    if givable(mid)==True :\n        additional = mid\n        low = mid+1\n    else :\n        high = mid-1\n\nprint( Ans + additional )",
        "language": "python"
      },
      "dst": {
        "code": "n,m,k = map(int,input().split())\nk1=n-k+1\ndef case(x):\n    res=x\n    if k==x:res+=x*(x-1)//2\n    elif k>x:res+=x*(x-1)//2+k-x\n    else:res+=x*(x-1)//2-((x-k)*(x-k+1)//2)\n    if k1==x:res+=x*(x-1)//2\n    elif k1>x:res+=x*(x-1)//2+k1-x\n    else:res+=x*(x-1)//2-((x-k1)*(x-k1+1)//2)\n    return res\ni,j=0,m\nwhile i+1<j:\n    mid = (i+j)//2\n    if case(mid)<=m:i=mid\n    else:j=mid\nif n==1:print(m)\nelse:print(i)",
        "language": "python"
      },
      "similarity": {
        "bleu": 0.16504503219507055,
        "jaccard": 0.5918367346938775,
        "tsed": 0.472321428571429,
        "cged": 0.39919354838709675,
        "codebleu": 0.2090371997335221
      }
    },
    {
      "case": "760_B",
      "src": {
        "code": "n,m,k = map(int, input().split())\nlow = 1\nhigh = m\nans = -1\nwhile (low<=high):\n\tmid = low+(high-low)//2\n\tnumReq = 0\n\tif mid>k: numReq += (mid*(mid+1))//2 - ((mid-k)*(mid-k+1))//2\n\telif mid<=k: numReq += (mid*(mid+1))//2 + (k-mid)\n\tif mid==1: numReq += (n-k)\n\telse:\n\t\tif (mid-1)>(n-k): numReq += (mid*(mid-1))//2 - ((mid-n+k)*(mid-n+k-1))//2\n\t\telif (mid-1)<=(n-k): numReq += (mid*(mid-1))//2 + (n-k-mid+1)\n\tif numReq > m: high = mid-1\n\telse: \n\t\tlow = mid+1\n\t\tans = mid\nprint(ans) ",
        "language": "python"
      },
      "dst": {
        "code": "def f(med):\n    left = k - 1\n    right = n - k\n    #print(med, left, right)\n    ans = 0\n    if med > left + 1:\n        d = med - left\n        ans += (med + d) * (med - d + 1) // 2\n    else:\n        ans += med * (med + 1) // 2\n        left -= (med - 1)\n        ans += left\n    #print(ans)\n    if med > right + 1:\n        d = med - right\n        ans += (med + d) * (med - d + 1) // 2\n    else:\n        ans += med * (med + 1) // 2\n        right -= (med - 1)\n        ans += right\n    #print(ans)\n    if ans - med <= m:\n        return True\n    else:\n        return False\n\nn, m, k = map(int, input().split())\nl = 1\nr = m + 1\nwhile r - l > 1:\n    med = (r + l) // 2\n    if f(med):\n        l = med\n    else:\n        r = med\nprint(l)\n",
        "language": "python"
      },
      "similarity": {
        "bleu": 0.2353172675523811,
        "jaccard": 0.6136363636363636,
        "tsed": 0.3153153153153148,
        "cged": 0.3307692307692308,
        "codebleu": 0.19040285715515998
      }
    },
    {
      "case": "760_B",
      "src": {
        "code": "hobbit, pillow, bed = map(int, input().split())\npillow -= hobbit\n#\nstart = 0\nend = pillow\n\nwhile start < end:\n  mid = round((start + end + 1)/2)\n\n  lside = int(min(bed - 1, mid - 1))\n  rside = int(min(hobbit - bed, mid - 1))\n\n  needed = mid + lside * ((mid - lside) + (mid - 1)) / 2 + rside * ((mid - rside) + (mid - 1)) / 2\n\n  if(needed > pillow):\n    end = mid - 1\n  else:\n    start = mid\n\nprint(start+1)\n   \t \t  \t   \t \t\t  \t \t \t    \t",
        "language": "python"
      },
      "dst": {
        "code": "n,m,k=[int(x) for x in input().split()]\nif(n==1):\n    print(m)\nelse:\n    m-=n\n    extra=0\n    while(m>min(k-1,extra)+min(n-k,extra)):\n        m-=min(k-1,extra)+min(n-k,extra)+1\n        extra+=1\n    print(1+extra)",
        "language": "python"
      },
      "similarity": {
        "bleu": 0.09975510519665692,
        "jaccard": 0.4318181818181818,
        "tsed": 0.3884892086330936,
        "cged": 0.35777126099706746,
        "codebleu": 0.2197726424962314
      }
    },
    {
      "case": "760_B",
      "src": {
        "code": "n, m, k = map(int, input().split())\n\nl, r = int(0), m\n\nwhile l+1 < r:\n\tmid = (l+r) // 2\n\t\n\tlpos = max(1, k-mid+1)\n\tlcnt = (mid - (k-lpos) + mid) * (k-lpos+1) // 2\n\n\trpos = min(n, k+mid-1)\n\trcnt = (mid - (rpos-k) + mid) * (rpos-k+1) // 2\n\n\tif lcnt + rcnt - mid > m-n:\n\t\tr = mid\n\telse:\n\t\tl = mid\n\nprint(l+1)",
        "language": "python"
      },
      "dst": {
        "code": "n, a, b = map(int, input().split())\nans = 1\na -= n\nl = b - 1\nr = n - b\n \nput = 1\nwhile (a >= put):\n    a -= put\n    ans += 1\n    put += (l > 0) + (r > 0)\n    if (l): l -= 1\n    if (r): r -= 1\n    if (l == r == 0):\n        ans += (a // put)\n        break\nprint(ans)",
        "language": "python"
      },
      "similarity": {
        "bleu": 0.1605258312126257,
        "jaccard": 0.55,
        "tsed": 0.4215827338129497,
        "cged": 0.2908011869436202,
        "codebleu": 0.19600975381420552
      }
    },
    {
      "case": "760_B",
      "src": {
        "code": "n, a, b = map(int, input().split())\nans = 1\na -= n\nl = b - 1\nr = n - b\n \nput = 1\nwhile (a >= put):\n    a -= put\n    ans += 1\n    put += (l > 0) + (r > 0)\n    if (l): l -= 1\n    if (r): r -= 1\n    if (l == r == 0):\n        ans += (a // put)\n        break\nprint(ans)",
        "language": "python"
      },
      "dst": {
        "code": "# n=int(input())\n#q.sort(key=lambda x:((x[1]-x[0]),-x[0]))\n# n,k=map(int,input().split())\n# arr=list(map(int,input().split()))\n#ls=list(map(int,input().split()))\n#for i in range(m):\n# cnt += (extra + k - 1) // k\n# n=int(input())\n#q.sort(key=lambda x:((x[1]-x[0]),-x[0]))\n# n,k=map(int,input().split())\n# arr=list(map(int,input().split()))\n#ls=list(map(int,input().split()))\n#for i in range(m):\n#from sys import stdin\n#n=int(stdin.readline())\n#for _ in range(int(input())):\nimport os\nimport sys\nfrom io import BytesIO, IOBase\n\nBUFSIZE = 8192\n\n\nclass FastIO(IOBase):\n    newlines = 0\n\n    def __init__(self, file):\n        self._fd = file.fileno()\n        self.buffer = BytesIO()\n        self.writable = \"x\" in file.mode or \"r\" not in file.mode\n        self.write = self.buffer.write if self.writable else None\n\n    def read(self):\n        while True:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            if not b:\n                break\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines = 0\n        return self.buffer.read()\n\n    def readline(self):\n        while self.newlines == 0:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            self.newlines = b.count(b\"\\n\") + (not b)\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines -= 1\n        return self.buffer.readline()\n\n    def flush(self):\n        if self.writable:\n            os.write(self._fd, self.buffer.getvalue())\n            self.buffer.truncate(0), self.buffer.seek(0)\n\n\nclass IOWrapper(IOBase):\n    def __init__(self, file):\n        self.buffer = FastIO(file)\n        self.flush = self.buffer.flush\n        self.writable = self.buffer.writable\n        self.write = lambda s: self.buffer.write(s.encode(\"ascii\"))\n        self.read = lambda: self.buffer.read().decode(\"ascii\")\n        self.readline = lambda: self.buffer.readline().decode(\"ascii\")\n\n\nsys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)\ninput = lambda: sys.stdin.readline().rstrip(\"\\r\\n\")\n##########################################################\ndef can(x):\n    fr=k-1\n    ba=n-k\n    total=x\n    if fr>0:\n        if x>fr:\n            total+=(x-fr)*fr+(fr-1)*fr//2\n        else:\n            total+=(x-1) * x // 2\n            total+=fr-(x-1)\n    if ba>0:\n        if x > ba :\n            total+=(x-ba)*ba+(ba-1)*ba//2\n        else:\n            total+=(x-1)*x//2\n            total+=(ba-(x-1))\n    #print(total)\n    if total<=m:\n        return True\n    else:\n        return False\nn,m,k= map(int, input().split())\nlow=1\nhigh=m-n+1\nans=-1\nwhile low<=high:\n    mid=(low+high)//2\n    #print(\"mid\",mid)\n    if can(mid):\n        ans=mid\n        low=mid+1\n    else:\n        high=mid-1\nprint(ans)\n\n",
        "language": "python"
      },
      "similarity": {
        "bleu": 0.00010414067286922016,
        "jaccard": 0.22429906542056074,
        "tsed": 0.28449502133712345,
        "cged": 0.22921348314606738,
        "codebleu": 0.06416579152517989
      }
    },
    {
      "case": "760_B",
      "src": {
        "code": "n, m, k = [int(i) for i in input().split()]\n\ndef one_sided(slots, x):\n    if slots >= x-1:\n        return (slots - x + 1) + (x-1)* x // 2\n    else:\n        return slots * ( 2* x - slots -1 ) // 2\n\ndef pillows_used(x):\n    left_slot = k -1\n    right_slot = n-k\n    return x + one_sided(left_slot, x) + one_sided(right_slot, x) <= m\n\ndef main():\n    left = 1\n    right = m\n    if pillows_used(m):\n        return m\n    mid = (left + right) // 2\n    while left != right:\n        if pillows_used(mid):\n            left = mid + 1\n        else:\n            right = mid\n        mid = (left + right) // 2\n    return mid - 1\n\nprint(main())",
        "language": "python"
      },
      "dst": {
        "code": "\"\"\"for p in range(int(input())):\n\n\tn,k=map(int,input().split(\" \"))\n\tnumber=input().split(\" \")\n\tchances=[k for i in range(n)]\n\n\tprev=-1\n\tprev_updated=-1\n\tlast_used=False\n\ttoSub=0\n\tstart=0\n\n\tprevSub=0\n\n\tif(number[0]=='1'):\n\t\tprev=0\n\t\tprev_updated=0\n\t\tstart=1\n\n\tfor i in range(start,n):\n\t\t\n\t\tif(number[i]=='1'):\n\t\t#\tprint(\"\\ni\",i,\"\\ntoSub\",toSub,\"\\nprevUpadted\",prev_updated,\"\\nprev\",prev,\"\\nlast_used\",last_used)\n\t\t\tf1=False\n#\t\t\ttoSub+=1\n\t\t\ttoSub=0\n\n\t\t\tzeros=i - prev_updated - 1\n\n\t\t\tif(last_used):\n\t\t\t\tzeros-=1\n\n\t\t\t#chances[i]-=toSub\n\n\t\t\t#print(prevSub,(i - prev - 1 ) +1)\n\t\t\tif(i - prev - 1 <= prevSub):\n\t\t\t\tchances[i]-= prevSub - (i - prev - 1 ) +1\n\t\t\t\tif(chances[i]<zeros):\n\t\t\t\t\tchances[i]=zeros\n\t\t\t\ttoSub+= prevSub - (i - prev - 1 ) +1\n\t\t\t\tf1=True\n\n\t\t\tif(zeros==0 or chances[i]==0):\n\t\t\t\tprev_updated=i\n\t\t\t\tprev=i\n\t\t\t\tlast_used=False\n\t\t\t\tprevSub=toSub\n\t\t\t\tcontinue\n\t\t#\tprint(\"\\nchances:  \",chances[i],\"\\t\\tzeroes :   \",zeros,\"\\t\\tprevSub :\",prevSub)\n\n\t\t\tif(chances[i]>zeros):\n\t\t#\t\tprint(\"\\t\\t\\t\\t1\")\n\t\t\t\tnumber[i-zeros]='1'\n\t\t\t\tnumber[i]='0'\n\t\t\t\tprev_updated=i-zeros\n\t\t\t\tlast_used=False\n\t\t\telif(chances[i]==zeros):\n\t\t#\t\tprint(\"\\t\\t\\t\\t2\")\n\t\t\t\tnumber[i]='0'\n\t\t\t\tnumber[i-chances[i]]='1'\n\t\t\t\tprev_updated=i-chances[i]\n\t\t\t\tlast_used=True\n\t\t\telse:\n\t\t#\t\tprint(\"\\t\\t\\t\\t3\")\n\t\t\t\tnumber[i]='0'\n\t\t\t\tnumber[i-chances[i]]='1'\n\t\t\t\tprev_updated=i-chances[i]\n\t\t\t\tlast_used=True\n\t\t\tprev=i\n\n\t\t\tprevSub=toSub\n\n\t\t\tif(prev_updated>2 and f1):\n\t\t\t\tif(number[prev_updated]=='1' and number[prev_updated-1]=='0' and number[prev_updated-2]=='1'):\n\t\t\t\t\tlast_used=False\n\t\t\t\t#if()\n\n\t\t#\tprint(\"\\ni\",i,\"\\ntoSub\",toSub,\"\\nprevUpadted\",prev_updated,\"\\nprev\",prev,\"\\nlast_used\",last_used)\n\t\t#\tprint(number)\n\t\telse:\n\t\t\ttoSub=0\n\n\tprint(*number)\n#\tprint(chances)\"\"\"\n\n\"\"\"class offer:\n\tdef __init__(self, n, fre):\n\t\tself.num = n\n\t\tself.free = fre\n\t\tself.delta= n-fre\n\t\t\n\nn,m,k=map(int,input().split(\" \"))\n\nshovel=list(map(int,input().split(\" \")))\n\n#dicti={}\n\noffers=[]\ntemp_arr=[False for i in range(n)]\n\nfor i in range(m):\n\tp,q=map(int,input().split(\" \"))\n\tif(p>k):\n\t\tcontinue\n\toffers.append(offer(p,q))\n#\tdicti[p]=q\n\n#for i in dicti:\n#\tdicti[i].sort()\t\n\nshovel.sort()\nshovel=shovel[:k+1]\n\noffers.sort(key=lambda x: x.delta/x.num,reverse=True)\n\nbestoffer=[]\n\nfor i in offers:\n\tif(not temp_arr[i.num]):\n\t\ttemp_arr[i.num]=True\n\t\tbestoffer.append(i)\n\ncost=0\n\nfor i in bestoffer:\n\t\n\t\nfor p in range(int(input())):\n\tarr=list(input())\n\n\tn=len(arr)\n\tfor i in range(n):\n\t\tarr[i]=ord(arr[i])-96\n\n\tarr.sort()\n\n\tarr1=arr[:n//2]\n\tarr2=arr[n//2:]\n\tarr=[]\n\t#print(arr,arr1,arr2)\n\ti1=n//2-1\n\ti2=n-i1-2\n\n\twhile (i1!=-1 and i2!=-1):\n\t\tarr.append(arr1[i1])\n\t\tarr.append(arr2[i2])\n\t\ti1-=1\n\t\ti2-=1\n\tif(i1!=-1):\n\t\tarr.append(arr1[i1])\n\telif(i2!=-1):\n\t\tarr.append(arr2[i2])\n\n\t#print(arr)\n\n\ts=\"\"\n\tfor i in range(n-1):\n\t\tif(abs(arr[i]-arr[i+1])==1):\n\t\t\ts=-1\n\t\t\tprint(\"No answer\")\n\t\t\tbreak\n\t\telse:\n\t\t\ts+=chr(arr[i]+96)\n\n\tif(s!=-1):\n\t\ts+=chr(arr[-1]+96)\n\t\tprint(s)\"\"\"\n\n\"\"\"\nn,m=map(int,input().split(\" \"))\n\nseti=[]\nans=[1 for i in range(n)]\n\n\nfor i in range(m):\n\tarr=list(map(int,input().split(\" \")))\n\t\n\tif(arr[0]>1):\n\t\tseti.append(set(arr[1:]))\n\telse:\n\t\tm-=1\n\nparent=[-1 for i in range(m)]\n#print(seti)\nfor i in range(m-1):\n\tfor j in range(i+1,m):\n\t\tif(parent[j]==-1):\n\t\t\tif(len(seti[i].intersection(seti[j]))>0):\n\t\t\t\tseti[i]=seti[i].union(seti[j])\n\t\t\t\tparent[j]=i\n\n#print(parent)\n\nfor i in range(m):\n\tif(parent[i]==-1):\n\t\ttemp=list(seti[i])\n\t\tstore=len(temp)\n\t\tfor j in temp:\n\t\t\tans[j-1]=store\n\nprint(*ans)\n\n\nfor p in range(int(input())):\n\tarr=list(input())\n\n\tn=len(arr)\n\tfor i in range(n):\n\t\tarr[i]=ord(arr[i])-96\n\n\tarr.sort()\n\n\tarr1=arr[:n//2]\n\tarr2=arr[n//2:]\n\tarr=[]\n\t#print(arr,arr1,arr2)\n\ti1=n//2-1\n\ti2=n-i1-2\n\n\twhile (i1!=-1 and i2!=-1):\n\t\tarr.append(arr1[i1])\n\t\tarr.append(arr2[i2])\n\t\ti1-=1\n\t\ti2-=1\n\tif(i1!=-1):\n\t\tarr.append(arr1[i1])\n\telif(i2!=-1):\n\t\tarr.append(arr2[i2])\n\n\ts=\"\"\n\tfor i in range(n-1):\n\t\tif(abs(arr[i]-arr[i+1])==1):\n\t\t\ts=-1\n\t\t\tprint(\"No answer\")\n\t\t\tbreak\n\t\telse:\n\t\t\ts+=chr(arr[i]+96)\n\n\tif(s!=-1):\n\t\ts+=chr(arr[-1]+96)\n\t\tprint(s)\n#n=0\"\"\"\n\nn,m,k=map(int,input().split(\" \"))\n\nm-=n\nans=1\n\nside1=k-1\nside2=n-k\n\nprevadd=1\nwhile m>=prevadd:\n\tm-=prevadd\n\tans+=1\t\n\tif(side1+side2==0):\n\t\tans+=m//n\n\t\tbreak\n\tif(side1>0):\n\t\tside1-=1\n\t\tprevadd+=1\n\tif(side2>0):\n\t\tside2-=1\n\t\tprevadd+=1\t\n\nprint(ans)",
        "language": "python"
      },
      "similarity": {
        "bleu": 6.682778881076698e-05,
        "jaccard": 0.25396825396825395,
        "tsed": 0.1611764705882345,
        "cged": 0.29702970297029707,
        "codebleu": 0.17122500290091625
      }
    },
    {
      "case": "701_D",
      "src": {
        "code": "def binSearch(n, L, v1, v2, k):\n    l = 0\n    r = L\n    while r-l > 0.000001:\n        d = (l+r)/2\n        td = d/v1\n        S = v2*td\n        g = d-S\n        tb = g/(v1+v2)\n        b = v1*tb\n        if n%k == 0:\n            a = n//k\n        else:\n            a = n//k + 1\n        if a*d-b*(a-1) > L:\n            r = d\n        else:\n            l = d\n    td = l / v1\n    S = v2 * td\n    g = l - S\n    tb = g / (v1 + v2)\n    b = v1 * tb\n    return l/v1 + (L-l)/v2\nn1, L1, v11, v21, k1 = map(int, input().split())\nprint('{0:.10f}'.format(binSearch(n1, L1, v21, v11, k1)))",
        "language": "python"
      },
      "dst": {
        "code": "n, L, v1, v2, k = map(int, input().split())\nn = (n + k - 1) // k * 2\ndif = v2 - v1\np1 = (n * v2 - dif) * L\np2 = (n * v1 + dif) * v2\nans = p1 / p2\nprint(ans)\n",
        "language": "python"
      },
      "similarity": {
        "bleu": 0.13967485065743626,
        "jaccard": 0.3888888888888889,
        "tsed": 0.19898477157360386,
        "cged": 0.2831325301204819,
        "codebleu": 0.29348051250979923
      }
    },
    {
      "case": "701_D",
      "src": {
        "code": "n, l, v1, v2, k = [int(x) for x in input().split()]\nx = (n+k-1)//k\nprint((l - ((l/v1)/((x/(v2-v1)) + ((x-1)/(v2+v1)) + (1/v1))))/v1)\n",
        "language": "python"
      },
      "dst": {
        "code": "s=input();\nli=s.split();\nn=int(li[0])\nl=int(li[1])\nv1=int(li[2])\nv2=int(li[3])\nk=int(li[4])\nt=n//k\nif n%k!=0:\n    t+=1\na=(v1+v2)*l/(v1+v2+2*(t-1)*v1)\nans=a/v2+(l-a)/v1\nprint(\"{0:.10f}\".format(ans))",
        "language": "python"
      },
      "similarity": {
        "bleu": 0.07260539263971912,
        "jaccard": 0.4523809523809524,
        "tsed": 0.2809523809523818,
        "cged": 0.36923076923076925,
        "codebleu": 0.0952141419948261
      }
    },
    {
      "case": "701_D",
      "src": {
        "code": "n, l, v1, v2, k = map(int, input().split())\ngrps = n // k + int(n % k > 0)\n\nr = 1 - (v2 - v1) * 1.0 / (v1 + v2)\nbd = l / (1 + (grps - 1) * r)\n\nprint(bd / v2 + (l - bd) / v1)\n\n",
        "language": "python"
      },
      "dst": {
        "code": "n, L, v1, v2, k = map(int, input().split())\nn = (n + k - 1) // k * 2\ndif = v2 - v1\np1 = (n * v2 - dif) * L\np2 = (n * v1 + dif) * v2\nans = p1 / p2\nprint(ans)\n",
        "language": "python"
      },
      "similarity": {
        "bleu": 0.32251457526710947,
        "jaccard": 0.59375,
        "tsed": 0.5291139240506328,
        "cged": 0.6057692307692308,
        "codebleu": 0.3372448422095061
      }
    },
    {
      "case": "701_D",
      "src": {
        "code": "n, l, v1, v2, k = map(int, input().split())\ngrps = n // k + int(n % k > 0)\n\nr = 1 - (v2 - v1) * 1.0 / (v1 + v2)\nbd = l / (1 + (grps - 1) * r)\n\nprint(bd / v2 + (l - bd) / v1)\n\n",
        "language": "python"
      },
      "dst": {
        "code": "array = list(map(int,input().split()))\nn = int(array[0])\nl = int(array[1])\nv1 = int(array[2])\nv2 = int(array[3])\nk = int(array[4])\n\nbus = n//k\nif n%k != 0:\n    bus += 1\n\nV = (v1+v2) + 2*v2*(bus-1)\nU = (v1+v2) + 2*v1*(bus-1)\n\nprint (l*V/U/v2)",
        "language": "python"
      },
      "similarity": {
        "bleu": 0.20093758880637488,
        "jaccard": 0.5641025641025641,
        "tsed": 0.42601626016260247,
        "cged": 0.5185185185185186,
        "codebleu": 0.12338155518862612
      }
    },
    {
      "case": "701_D",
      "src": {
        "code": "#coding=utf-8\nimport sys\neps = 1e-6\n\ndef solve(n, l, v1, v2):\n    t2 = 1.0 * (v1 + v2) * l / (n * (v1 + v2) * v2 - (n - 1) * v2 * (v2 - v1))\n    l2 = v2 * t2\n    l1 = l - l2\n    t1 = l1 / v1\n    #print(t1, l1, t2, l2)\n    return t1 + t2\n\n#print(solve(3, 6, 1, 2))\n#print(solve(1, 10, 1, 2))\n\nn, t, v1, v2, k = map(int, input().split())\nn = (n + k - 1) // k\n\nprint(solve(n, t, v1, v2))",
        "language": "python"
      },
      "dst": {
        "code": "n, L, v1, v2, k = map(int, input().split())\nn = (n + k - 1) // k * 2\ndif = v2 - v1\np1 = (n * v2 - dif) * L\np2 = (n * v1 + dif) * v2\nans = p1 / p2\nprint(ans)\n",
        "language": "python"
      },
      "similarity": {
        "bleu": 0.23692368798033703,
        "jaccard": 0.425531914893617,
        "tsed": 0.31206896551724167,
        "cged": 0.4065040650406504,
        "codebleu": 0.36912069890657695
      }
    },
    {
      "case": "701_D",
      "src": {
        "code": "n, l, v1, v2, k=map(int,input().split())\nn=(n+k-1)//k\nt0=l/v1\nt1=l/v2\n\nif n==1:\n    print(t1)\nelse:\n    for k in range(50):\n        t=(t0+t1)/2\n        d2=v2*t\n        x2=(d2-l)/(n-1)/2\n        u2=(d2-(n-1)*x2)/n\n        tt=u2/v2+(l-u2)/v1\n        if tt>t: t1=t\n        else: t0=t\n    print(t)",
        "language": "python"
      },
      "dst": {
        "code": "array = list(map(int,input().split()))\nn = int(array[0])\nl = int(array[1])\nv1 = int(array[2])\nv2 = int(array[3])\nk = int(array[4])\n\nbus = n//k\nif n%k != 0:\n    bus += 1\n\nV = (v1+v2) + 2*v2*(bus-1)\nU = (v1+v2) + 2*v1*(bus-1)\n\nprint (l*V/U/v2)",
        "language": "python"
      },
      "similarity": {
        "bleu": 0.17527415847859873,
        "jaccard": 0.4791666666666667,
        "tsed": 0.40869565217391307,
        "cged": 0.31999999999999995,
        "codebleu": 0.17741742865240906
      }
    },
    {
      "case": "701_D",
      "src": {
        "code": "def binSearch(n, L, v1, v2, k):\n    l = 0\n    r = L\n    while r-l > 0.000001:\n        d = (l+r)/2\n        td = d/v1\n        S = v2*td\n        g = d-S\n        tb = g/(v1+v2)\n        b = v1*tb\n        if n%k == 0:\n            a = n//k\n        else:\n            a = n//k + 1\n        if a*d-b*(a-1) > L:\n            r = d\n        else:\n            l = d\n    td = l / v1\n    S = v2 * td\n    g = l - S\n    tb = g / (v1 + v2)\n    b = v1 * tb\n    return l/v1 + (L-l)/v2\nn1, L1, v11, v21, k1 = map(int, input().split())\nprint('{0:.10f}'.format(binSearch(n1, L1, v21, v11, k1)))",
        "language": "python"
      },
      "dst": {
        "code": "n, l, v1, v2, k = map(int, input().split())\ndiff = v2 - v1\nn = (n + k - 1) // k * 2\np1 = (n * v2 - diff) * l\np2 = (n * v1 + diff) * v2\nprint(p1 / p2)\n",
        "language": "python"
      },
      "similarity": {
        "bleu": 0.12471606564104555,
        "jaccard": 0.39622641509433965,
        "tsed": 0.1796954314720811,
        "cged": 0.26747720364741645,
        "codebleu": 0.26029761460984074
      }
    },
    {
      "case": "701_D",
      "src": {
        "code": "n, l, v1, v2, k = map(int, input().split())\ncol = (n + k - 1) // k\nm = l / (1 + (2 * (col - 1) * v1) / (v1 + v2))\nprint(m / v2 + (l - m) / v1)\n",
        "language": "python"
      },
      "dst": {
        "code": "n, l, v1, v2, k = list(map(int, input().split()))\nn = (n+k-1)//k\nt = l / ((v1 + (v2 - v1) * v1 / (v1 + v2)) * (n - 1) + v2)\nprint(t * n + t * (v2 - v1) / (v1 + v2) * (n - 1))",
        "language": "python"
      },
      "similarity": {
        "bleu": 0.46707911655113854,
        "jaccard": 0.8,
        "tsed": 0.7647058823529411,
        "cged": 0.7348837209302326,
        "codebleu": 0.33583569092088267
      }
    },
    {
      "case": "701_D",
      "src": {
        "code": "def binSearch(n, L, v1, v2, k):\n    l = 0\n    r = L\n    while r-l > 0.000001:\n        d = (l+r)/2\n        td = d/v1\n        S = v2*td\n        g = d-S\n        tb = g/(v1+v2)\n        b = v1*tb\n        if n%k == 0:\n            a = n//k\n        else:\n            a = n//k + 1\n        if a*d-b*(a-1) > L:\n            r = d\n        else:\n            l = d\n    td = l / v1\n    S = v2 * td\n    g = l - S\n    tb = g / (v1 + v2)\n    b = v1 * tb\n    return l/v1 + (L-l)/v2\nn1, L1, v11, v21, k1 = map(int, input().split())\nprint('{0:.10f}'.format(binSearch(n1, L1, v21, v11, k1)))",
        "language": "python"
      },
      "dst": {
        "code": "s=input();\nli=s.split();\nn=int(li[0])\nl=int(li[1])\nv1=int(li[2])\nv2=int(li[3])\nk=int(li[4])\nt=n//k\nif n%k!=0:\n    t+=1\na=(v1+v2)*l/(v1+v2+2*(t-1)*v1)\nans=a/v2+(l-a)/v1\nprint(\"{0:.10f}\".format(ans))",
        "language": "python"
      },
      "similarity": {
        "bleu": 0.18136462185390476,
        "jaccard": 0.4666666666666667,
        "tsed": 0.34822335025380724,
        "cged": 0.26815642458100564,
        "codebleu": 0.2222577760224289
      }
    },
    {
      "case": "701_D",
      "src": {
        "code": "# coding: utf-8\nimport math\n\nn, l, v1, v2, k = map(int, input().split(\" \"))\n\nif n <= k:\n    print(l/v2)\nelse:\n    f = math.ceil(n/k)\n    x = (v2 - v1) / (2 * v1)\n    a = l / (f + x)\n    b = x * a\n    t = (f * (a + b) + (f-1) * b) / v2\n    print(t)\n",
        "language": "python"
      },
      "dst": {
        "code": "tmp = input()\n\ntmp = tmp.split(' ')\n\nn = int(tmp[0])\nl = int(tmp[1])\nv1 = int(tmp[2])\nv2 = int(tmp[3])\nk = int(tmp[4])\n\ndef canGo(timeLimit):\n    # dis = (v1 * t1) +v2(timeLimit - t1)\n    # dis = v1t1 v2tL - v2t1\n    # dis =  (v1 - v2)t1 + v2tl\n    # dis - v2tl = (v1-v2) t1\n\n    t1 = ( l - v2 * timeLimit) / (v1-v2)\n    t2 = timeLimit-t1 #bus\n\n    timeSpent = 0\n    pupilLeft = n\n    busPos = 0\n    pupilPos = 0\n    #print ('limit', timeLimit, 't2', t2)\n    while (timeSpent+ 0.0000005 < timeLimit):\n        if (pupilLeft <= 0):\n            return True\n        # bus go back\n        timeToMeet = (busPos-pupilPos)/(v1+v2)\n        timeSpent = timeSpent + timeToMeet\n        #print('busPos', busPos)\n        if (timeSpent+ 0.0000005 > timeLimit):\n            return False\n        busPos = busPos - v2 * timeToMeet\n        #print('busPos', busPos)\n        pupilPos = pupilPos + v1 * timeToMeet\n        # pick up\n        pupilLeft = pupilLeft - k\n        timeSpent  = timeSpent + t2\n        if (timeSpent+ 0.0000005 > timeLimit):\n            return False\n        pupilPos = pupilPos + v1 * t2\n        busPos = busPos + v2*t2\n        #print('busPos', busPos)\n    if pupilLeft<=0:\n        return False\n    else:\n        return True\n\ndef bsearch():\n    right = l / v1\n    left = l / v2\n\n    while (left + 0.0000005 < right):\n        mid = (left+ right )/2\n        #print('left', left,'right', right,'mid',mid)\n        result = canGo(mid)\n        if (result):\n            right = mid\n        else:\n            left = mid\n\n    return left\n\n\nprint(bsearch())\n",
        "language": "python"
      },
      "similarity": {
        "bleu": 0.008490944697784221,
        "jaccard": 0.3333333333333333,
        "tsed": 0.3287197231833906,
        "cged": 0.3152709359605911,
        "codebleu": 0.11336840771862983
      }
    },
    {
      "case": "527_A",
      "src": {
        "code": "a, b = map(int, input().split())\nans = 0\n\nwhile min(a, b) != 0:\n    ans += max(a, b) // min(a, b)\n    a, b = min(a, b), max(a, b) % min(a, b)\nprint(ans)\n\n",
        "language": "python"
      },
      "dst": {
        "code": "a,b=map(int,input().split())\ncount=0\nwhile b>1:\n\tt=a%b\n\tcount+=a//b\n\ta=b\n\tb=t\nif b!=0:\n\tprint(count+a)\nelse:\n\tprint(count)",
        "language": "python"
      },
      "similarity": {
        "bleu": 0.30466539893737654,
        "jaccard": 0.6785714285714286,
        "tsed": 0.5098591549295775,
        "cged": 0.5524861878453038,
        "codebleu": 0.30099658391441053
      }
    },
    {
      "case": "527_A",
      "src": {
        "code": "a,b=map(int,input().split())\nres=0\nwhile a!=0 and b!=0:\n    if a>=b:\n        res+=a//b\n        a=a%b\n    elif b>a:\n        res+=b//a\n        b=b%a\nprint(res)\n",
        "language": "python"
      },
      "dst": {
        "code": "a, b = [int(x) for x in input().split()]\nc = 0\nwhile a > 0 and b > 0:\n    if a > b:\n        c += a // b\n        a = a % b\n    elif b > a:\n        c += b // a\n        b = b % a\nprint(c)\n",
        "language": "python"
      },
      "similarity": {
        "bleu": 0.6148858097558596,
        "jaccard": 0.7,
        "tsed": 0.9388888888888888,
        "cged": 0.5210084033613445,
        "codebleu": 0.34685746370166104
      }
    },
    {
      "case": "527_A",
      "src": {
        "code": "# The key idea is to replace repeating subtraction operations with integer division operations\na, b = map(int, input().split())\n\nct = 0\nwhile a > 0:\n    if a < b:\n        a,b = b,a\n    ct += a//b\n    a = a % b\n        \nprint(ct)",
        "language": "python"
      },
      "dst": {
        "code": "a, b = (int(x) for x in input().split())\nans = 0\nwhile a * b != 0:\n    tmp = a // b\n    ans += tmp\n    a -= tmp * b\n    if a < b:\n        a, b = b, a\nprint(ans)\n",
        "language": "python"
      },
      "similarity": {
        "bleu": 0.4284560652173415,
        "jaccard": 0.4186046511627907,
        "tsed": 0.6461538461538462,
        "cged": 0.5209302325581395,
        "codebleu": 0.3698423346010378
      }
    },
    {
      "case": "527_A",
      "src": {
        "code": "def gcd(x, y): return 0 if y == 0 else x // y + gcd(y, x % y)\nx, y = list(map(int, input().split()))\nprint(gcd(x, y))\n#######\n",
        "language": "python"
      },
      "dst": {
        "code": "a,b=[int(i) for i in input().split()]\n\nk=0\n\nwhile a!=0 and b!=0:\n    if a>b:\n        k=k+a//b\n        a=a%b\n    else:\n        k=k+b//a\n        b=b%a\n    \nprint(k)\n",
        "language": "python"
      },
      "similarity": {
        "bleu": 0.11864515070581477,
        "jaccard": 0.4444444444444444,
        "tsed": 0.2383561643835625,
        "cged": 0.2597402597402597,
        "codebleu": 0.12123809945586592
      }
    },
    {
      "case": "527_A",
      "src": {
        "code": "import math,string,itertools,fractions,heapq,collections,re,array,bisect,sys,random,time,copy,functools\n\nsys.setrecursionlimit(10**7)\ninf = 10**20\neps = 1.0 / 10**10\nmod = 10**9+7\ndd = [(-1,0),(0,1),(1,0),(0,-1)]\nddn = [(-1,0),(-1,1),(0,1),(1,1),(1,0),(1,-1),(0,-1),(-1,-1)]\n\ndef LI(): return [int(x) for x in sys.stdin.readline().split()]\ndef LI_(): return [int(x)-1 for x in sys.stdin.readline().split()]\ndef LF(): return [float(x) for x in sys.stdin.readline().split()]\ndef LS(): return sys.stdin.readline().split()\ndef I(): return int(sys.stdin.readline())\ndef F(): return float(sys.stdin.readline())\ndef S(): return input()\ndef pf(s): return print(s, flush=True)\n\n\ndef main():\n    a,b = LI()\n\n    if a > b:\n        a,b = b,a\n\n    r = 0\n    while a > 0:\n        r += b // a\n        a,b = b%a, a\n\n    return r\n\n\nprint(main())\n\n\n",
        "language": "python"
      },
      "dst": {
        "code": "a,b = map(int, input().split())\nc=0\nwhile a and b:\n\tc += a//b\n\ta = a%b\n\ta,b = b,a\nprint(c)\n",
        "language": "python"
      },
      "similarity": {
        "bleu": 0.053606029881913354,
        "jaccard": 0.2328767123287671,
        "tsed": 0.13096774193548377,
        "cged": 0.33725490196078434,
        "codebleu": 0.20990183355600397
      }
    },
    {
      "case": "527_A",
      "src": {
        "code": "s = input()\ns = s.split()\na = int(s[0])\nb = int(s[1])\ncount = 0\nwhile a > 1 and b > 1:\n\tcount += a // b\n\ta, b = (b , a % b)\nif a != 0 and b != 0:\n\tcount += a\nprint(count)",
        "language": "python"
      },
      "dst": {
        "code": "def lsn():\n    global a, b, k\n    k+=a//b\n    a=a-(a//b)*b\n    a, b=max(a, b), min(a, b)\na, b=input().split()\na=int(a)\nb=int(b)\nk=0\nwhile (a>0) and (b>0):\n    lsn()\nprint(k)\n",
        "language": "python"
      },
      "similarity": {
        "bleu": 0.28374347804409666,
        "jaccard": 0.5294117647058824,
        "tsed": 0.4434782608695653,
        "cged": 0.35652173913043483,
        "codebleu": 0.17265238742952724
      }
    },
    {
      "case": "527_A",
      "src": {
        "code": "'''\nCreated on May 5, 2016\n\n@author: Md. Rezwanul Haque\n'''\na,b = map(int,input().split())\nans = 0\nwhile a>0 and b>0:\n    if a>=b:\n        ans = ans + a//b\n        a = a%b\n    else:\n        ans = ans + b//a \n        b = b%a \nprint(ans)",
        "language": "python"
      },
      "dst": {
        "code": "a, b = sorted(map(int, input().split()))\nA, B = a, b\nships = 0\nwhile 0 < a < b:\n    ships += b // a\n    a, b = sorted([b % a, a])\nprint(ships)",
        "language": "python"
      },
      "similarity": {
        "bleu": 0.27178914972390394,
        "jaccard": 0.45,
        "tsed": 0.4480000000000001,
        "cged": 0.42533936651583715,
        "codebleu": 0.2402796943838221
      }
    },
    {
      "case": "527_A",
      "src": {
        "code": "# -*- coding: utf-8 -*-\n\"\"\"\nCreated on Thu Feb 14 21:27:37 2019\n\n@author: avina\n\"\"\"\nn,m = map(int, input().strip().split())\nk = 0\n   \nwhile n != 0 and m != 0:\n    if n > m:\n        k += int(n/m)\n        n = n%m\n    else:\n        k += int(m/n)\n        m = m%n\nprint(k)        \n\n",
        "language": "python"
      },
      "dst": {
        "code": "raw = str(input()).split()\na = int(raw[0])\nb = int(raw[1])\nc = 0\n\nwhile(a != 0 and b != 0):\n    if (a > b):\n        c += int(a/b)\n        a = a % b\n    else:\n        c += int(b/a)\n        b = b % a\n\nprint(c)\n\n",
        "language": "python"
      },
      "similarity": {
        "bleu": 0.16617372542826425,
        "jaccard": 0.37254901960784315,
        "tsed": 0.6426966292134831,
        "cged": 0.8636363636363636,
        "codebleu": 0.25437838408634106
      }
    },
    {
      "case": "527_A",
      "src": {
        "code": "__author__ = 'myduomilia'\n\na, b = list(map(int, input().split()))\nans = 0\nwhile a * b > 0:\n    if a > b:\n        ans += a // b\n        a = a % b\n    else:\n        ans += b // a\n        b = b % a\nprint(ans)\n",
        "language": "python"
      },
      "dst": {
        "code": "a, b = map(int, input().split())\ncnt = 0\n\nif a < b:\n\ta, b = b, a\n\nwhile a > 0 and b > 0 and a != b:\n\tcnt += a // b\n\ta, b = b, a % b\n\nprint(cnt)\n",
        "language": "python"
      },
      "similarity": {
        "bleu": 0.39809110766941397,
        "jaccard": 0.6666666666666666,
        "tsed": 0.527027027027027,
        "cged": 0.4271844660194175,
        "codebleu": 0.257934577068768
      }
    },
    {
      "case": "527_A",
      "src": {
        "code": "a,b=map(int,input().split());x=0\nwhile b:x+=a//b;a,b=b,a%b\nprint(x)",
        "language": "python"
      },
      "dst": {
        "code": "a, b = map(int, input().split())\nc = 0\nif a < b:\n  a, b = b, a\nwhile b != 0:\n  c += a // b\n  a %= b\n  a, b = b, a\nprint(c)",
        "language": "python"
      },
      "similarity": {
        "bleu": 0.4570908485427714,
        "jaccard": 0.75,
        "tsed": 0.7225806451612903,
        "cged": 0.6473988439306358,
        "codebleu": 0.31475174250985244
      }
    },
    {
      "case": "p02350",
      "src": {
        "code": "#####segfunc#####\ndef segfunc(x, y):\n    return min(x, y)\n#################\n\n#####ide_ele#####\nide_ele = 2**31 - 1\n#################\n\nclass LazySegmentTree:\n    \"\"\"\n    init(init_val, ide_ele): init_val O(N)\n    update(l, r, x): [l, r)x O(logN)\n    query(l, r): [l, r)segfunc O(logN)\n    \"\"\"\n    def __init__(self, init_val, segfunc, ide_ele):\n        \"\"\"\n        init_val: \n        segfunc: \n        ide_ele: \n        num: n2\n        data: (1-index)\n        lazy: (1-index)\n        \"\"\"\n        n = len(init_val)\n        self.segfunc = segfunc\n        self.ide_ele = ide_ele\n        self.num = 1 << (n - 1).bit_length()\n        self.data = [ide_ele] * 2 * self.num\n        self.lazy = [None] * 2 * self.num\n        # \n        for i in range(n):\n            self.data[self.num + i] = init_val[i]\n        # \n        for i in range(self.num - 1, 0, -1):\n            self.data[i] = self.segfunc(self.data[2 * i], self.data[2 * i + 1])\n\n    def gindex(self, l, r):\n            \"\"\"\n            \n            lm: \n            rm: \n            \"\"\"\n            l += self.num\n            r += self.num\n            lm = l >> (l & -l).bit_length()\n            rm = r >> (r & -r).bit_length()\n\n            while r > l:\n                if l <= lm:\n                    yield l\n                if r <= rm:\n                    yield r\n                r >>= 1\n                l >>= 1\n            while l:\n                yield l\n                l >>= 1\n\n    def propagates(self, *ids):\n        \"\"\"\n        \n        ids:  \n        \"\"\"\n        for i in reversed(ids):\n            v = self.lazy[i]\n            if v is None:\n                continue\n            self.lazy[2 * i] = v\n            self.lazy[2 * i + 1] = v\n            self.data[2 * i] = v\n            self.data[2 * i + 1] = v\n            self.lazy[i] = None\n\n    def update(self, l, r, x):\n        \"\"\"\n        [l, r)x\n        l, r: index(0-index)\n        x: update value\n        \"\"\"\n        *ids, = self.gindex(l, r)\n        self.propagates(*ids)\n        l += self.num\n        r += self.num\n        while l < r:\n            if l & 1:\n                self.lazy[l] = x\n                self.data[l] = x\n                l += 1\n            if r & 1:\n                self.lazy[r - 1] = x\n                self.data[r - 1] = x\n            r >>= 1\n            l >>= 1\n        for i in ids:\n            self.data[i] = self.segfunc(self.data[2 * i], self.data[2 * i + 1])\n\n\n    def query(self, l, r):\n        \"\"\"\n        [l, r)segfunc\n        l: index(0-index)\n        r: index(0-index)\n        \"\"\"\n        *ids, = self.gindex(l, r)\n        self.propagates(*ids)\n\n        res = self.ide_ele\n\n        l += self.num\n        r += self.num\n        while l < r:\n            if l & 1:\n                res = self.segfunc(res, self.data[l])\n                l += 1\n            if r & 1:\n                res = self.segfunc(res, self.data[r - 1])\n            l >>= 1\n            r >>= 1\n        return res\nn, q = [int(x) for x in input().split()]\nseg = LazySegmentTree([ide_ele]*n, segfunc, ide_ele)\nfor _ in range(q):\n    a, *b = [int(x) for x in input().split()]\n    if a == 1:\n        s, t = b\n        print(seg.query(s, t + 1))\n    else:\n        s, t, x = b\n        seg.update(s, t + 1, x)\n",
        "language": "python"
      },
      "dst": {
        "code": "import math\nfrom collections import deque\n\n\nclass SegmentTree:\n    __slots__ = [\"elem_size\", \"tree_size\", \"tree\", \"lazy\"]\n\n    def __init__(self, a: list, default: int):\n        real_size = len(a)\n        self.elem_size = 1 << math.ceil(math.log2(real_size))\n        self.tree_size = 2 * self.elem_size\n        self.tree = [default]*self.elem_size + a + [default]*(self.elem_size - real_size)\n        self.lazy = [None]*self.tree_size\n        self.init_tree()\n\n    def init_tree(self):\n        tree = self.tree\n        for i in range(self.elem_size-1, 0, -1):\n            left, right = tree[i << 1], tree[(i << 1)+1]\n            # ===== change me =====\n            tree[i] = left if left < right else right\n\n    def get_indexes(self, l: int, r: int):\n        '''[x, y)'''\n        l, r, targets, path, p_l, p_r, = l+self.elem_size, r+self.elem_size, deque(), deque(), 0, 0\n        t_ap, p_ap = targets.append, path.appendleft\n\n        while l < r:\n            if l & 1:\n                t_ap(l)\n                p_l = p_l or l >> 1\n                l += 1\n            if r & 1:\n                r -= 1\n                t_ap(r)\n                p_r = p_r or r >> 1\n            l, r = l >> 1, r >> 1\n\n        deepest = (p_l, p_r)\n\n        while p_l > 1 or p_r > 1:\n            if p_l > 1:\n                p_ap(p_l)\n            if p_l != p_r > 1:\n                p_ap(p_r)\n            p_l >>= 1\n            p_r >>= 1\n\n        #print(targets, path)\n        return targets, path, deepest\n\n    def propagate(self, indexes: list, value: int = None):\n        tree, lazy, elem_size = self.tree, self.lazy, self.elem_size\n        if value is None:\n            for n in indexes:\n                if lazy[n] is None:\n                    continue\n                tree[n] = lazy[n]\n                if n < elem_size:\n                    lazy[n << 1] = lazy[(n << 1)+1] = lazy[n]\n                lazy[n] = None\n        else:\n            for n in indexes:\n                if n < elem_size:\n                    lazy[n << 1] = lazy[(n << 1)+1] = value\n                tree[n] = value\n                lazy[n] = None\n\n    def get_indexes_with_propagation(self, l: int, r: int, current_node: int, l_end: int, r_end: int):\n        # print(l,r,current_node,l_end,r_end,self.lazy[current_node])\n        indexes = []\n        tree, lazy = self.tree, self.lazy\n        lazy_value, lazy[current_node] = lazy[current_node], None\n        left_child, right_child = current_node << 1, (current_node << 1) + 1\n\n        if lazy_value is not None:\n            tree[current_node] = lazy_value\n            if left_child < self.tree_size:\n                lazy[left_child] = lazy[right_child] = lazy_value\n\n        if l == l_end and r == r_end:\n            return [current_node]\n\n        mid = (l_end + r_end) // 2\n\n        if l < mid:\n            l_r = r if r < mid else mid\n            indexes += self.get_indexes_with_propagation(l, l_r, left_child, l_end, mid)\n        if r > mid:\n            r_l = l if mid < l else mid\n            indexes += self.get_indexes_with_propagation(r_l, r, right_child, mid, r_end)\n\n        return indexes\n\n    def update_lazy(self, l, r, value):\n        '''\n        indexes = sorted(self.get_indexes_with_propagation(l, r, 1, 0, self.elem_size))\n        l = self.elem_size\n        lazy, tree, update = self.lazy, self.tree, self.update_tree\n        for n in indexes:\n            lazy[n] = None\n            if n < l:\n                lazy[n << 1] = value\n                lazy[(n << 1)+1] = value\n            tree[n] = value\n            update(n)\n        print(\"update_lazy\",indexes)\n        '''\n        targets, paths, deepest = self.get_indexes(l, r)\n        self.propagate(paths)\n        self.propagate(targets, value)\n        self.update_tree(deepest[0])\n        self.update_tree(deepest[1])\n\n    def get_value(self, l: int, r: int):\n        '''\n        tree = self.tree\n        indexes = self.get_indexes_with_propagation(l, r, 1, 0, self.elem_size)\n        update = self.update_tree\n        for n in indexes:\n            update(n)\n        '''\n        tree = self.tree\n        targets, paths, deepest = self.get_indexes(l, r)\n        self.propagate(paths)\n        self.propagate(targets)\n        self.update_tree(deepest[0])\n        self.update_tree(deepest[1])\n\n        # ===== change me =====\n        #print([(n,tree[n]) for n in indexes])\n        return min(tree[n] for n in targets)\n\n    def update_tree(self, k: int):\n        tree, lazy = self.tree, self.lazy\n        if k >= self.elem_size:\n            k >>= 1\n\n        while k > 0:\n            left, right = k << 1, (k << 1)+1\n            if lazy[k] is None:\n                if lazy[left] is not None:\n                    tree[left] = lazy[left]\n                if lazy[right] is not None:\n                    tree[right] = lazy[right]\n                tree[k] = tree[left] if tree[left] < tree[right] else tree[right]\n            else:\n                tree[left] = tree[right] = tree[k] = lazy[k]\n                lazy[left] = lazy[right] = lazy[k] = None\n            # ===== change me =====\n\n            k >>= 1\n\n    def set_value(self, i: int, value: int, op: str):\n        k = self.elem_size + i\n        if op == \"=\":\n            self.tree[k] = value\n        elif op == \"+\":\n            self.tree[k] += value\n        self.update_tree(k)\n\n\nn, q = map(int, input().split())\nrmq = SegmentTree([2**31-1]*n, 2**31-1)\nans = []\nappend = ans.append\nfor _ in [0]*q:\n    l = list(map(int, input().split()))\n    if l[0] == 0:\n        rmq.update_lazy(l[1], l[2]+1, l[3])\n        #print(rmq.get_indexes(l[1],l[2]+1))\n    else:\n        a = rmq.get_value(l[1], l[2]+1)\n        #print(rmq.get_indexes(l[1],l[2]+1))\n        append(a)\n    #print(rmq.tree,rmq.lazy)\n\nprint(\"\\n\".join([str(n) for n in ans]))",
        "language": "python"
      },
      "similarity": {
        "bleu": 0.1423666713725034,
        "jaccard": 0.32075471698113206,
        "tsed": 0.3821712268314212,
        "cged": 0.0,
        "codebleu": 0.16383479848859756
      }
    },
    {
      "case": "p02350",
      "src": {
        "code": "import sys\ninput = sys.stdin.readline\nINF = 2**31 - 1\n\nclass LazySegmentTree:\n    def __init__(self, n):\n        LV = (n-1).bit_length()\n        self.N0 = 2 ** LV\n        self.data = [INF] * (2*self.N0)\n        self.lazy = [None] * (2*self.N0)\n        \n    def gindex(self, l, r):\n        L = l + self.N0; R = r + self.N0\n        lm = (L // (L & -L)) >> 1\n        rm = (R // (R & -R)) >> 1\n    \n        while L < R:\n            if R <= rm:\n                yield R\n            if L <= lm:\n                yield L\n            \n            L >>= 1; R >>= 1\n        \n        while L:\n            yield L\n            L >>= 1\n\n    def propagates(self, *ids):\n        for i in reversed(ids):\n            v = self.lazy[i-1]\n            \n            if v is None:\n                continue\n            \n            self.lazy[2*i-1] = self.data[2*i-1] = self.lazy[2*i] = self.data[2*i] = v\n            self.lazy[i-1] = None\n\n    def update(self, l, r, x):\n        *ids, = self.gindex(l, r)\n        self.propagates(*ids)\n\n        L = self.N0 + l; R = self.N0 + r\n        \n        while L < R:\n            if R & 1:\n                R -= 1\n                self.lazy[R-1] = self.data[R-1] = x\n            if L & 1:\n                self.lazy[L-1] = self.data[L-1] = x\n                L += 1\n                \n            L >>= 1; R >>= 1\n            \n        for i in ids:\n            self.data[i-1] = min(self.data[2*i-1], self.data[2*i])\n\n    def query(self, l, r):\n        self.propagates(*self.gindex(l, r))\n        L = self.N0 + l; R = self.N0 + r\n\n        s = INF\n        \n        while L < R:\n            if R & 1:\n                R -= 1\n                s = min(s, self.data[R-1])\n            if L & 1:\n                s = min(s, self.data[L-1])\n                L += 1\n                \n            L >>= 1; R >>= 1\n            \n        return s\n\nn, q = map(int, input().split())\nlst = LazySegmentTree(n)\n\nfor _ in range(q):\n    que = list(map(int, input().split()))\n    \n    if que[0] == 0:\n        s, t, x = que[1], que[2], que[3]\n        lst.update(s, t+1, x)\n    elif que[0] == 1:\n        s, t = que[1], que[2]\n        print(lst.query(s, t+1))\n",
        "language": "python"
      },
      "dst": {
        "code": "\ndef func(x,y):\n    return min(x,y)\n\nclass LazySegmentTree():\n    def __init__(self, n):\n        self.lv = (n-1).bit_length()\n        self.n = 2 ** self.lv\n        self.arr = [2**31-1] * (2*self.n-1)\n        self.lazy = [None] * (2*self.n-1)\n\n    #\n    def getidx(self, l, r):\n        L = (l + self.n) >> 1\n        R = (r + self.n) >> 1\n        lc = 0 if l & 1 else (L & -L).bit_length()\n        rc = 0 if r & 1 else (R & -R).bit_length()\n        for i in range(self.lv):\n            if rc <= i:\n                yield R\n            if L < R and lc <= i:\n                yield L\n            L >>= 1; R >>=1\n\n    #\n    def propagate(self,*ids):\n        for i in reversed(ids):\n            v = self.lazy[i-1]\n            if v is None:\n                continue\n            self.lazy[2*i-1] = self.arr[2*i-1] = self.lazy[2*i] = self.arr[2*i] = v\n            self.lazy[i-1] = None\n\n    #[l, r] x\n    def update(self,l,r,x):\n        #[l, r)\n        r+=1\n        *ids, = self.getidx(l,r)\n        self.propagate(*ids)\n\n        L = self.n + l; R = self.n + r\n        while L < R:\n            if R & 1:\n                R -=1\n                self.lazy[R-1] = self.arr[R-1] = x\n            if L & 1:\n                self.lazy[L-1] = self.arr[L-1] = x\n                L += 1\n            L >>= 1; R >>= 1\n\n        for i in ids:\n            self.arr[i-1] = func(self.arr[2*i-1], self.arr[2*i])\n\n    #[l, r]\n    def query(self,l,r):\n        #[l, r)\n        r+=1\n        self.propagate(*self.getidx(l,r))\n        L = self.n + l; R = self.n + r\n\n        s = 2**31-1\n        while L < R:\n            if R & 1:\n                R -=1\n                s = func(s, self.arr[R-1])\n            if L & 1:\n                s = func(s, self.arr[L-1])\n                L += 1\n            L >>= 1; R >>= 1\n        return s\n\nimport sys\ninput=sys.stdin.readline\nn,q=map(int,input().split())\nsg=LazySegmentTree(n)\nfor _ in range(q):\n    que=list(map(int,input().split()))\n    if que[0]==0:\n        y,l,r,x=que\n        sg.update(l,r,x)\n    else:\n        y,l,r=que\n        print(sg.query(l,r))\n\n",
        "language": "python"
      },
      "similarity": {
        "bleu": 0.6518263691349324,
        "jaccard": 0.6774193548387096,
        "tsed": 0.8102400000000001,
        "cged": 0.0,
        "codebleu": 0.456016361737408
      }
    },
    {
      "case": "p02350",
      "src": {
        "code": "import sys\nclass Lazysegtree:\n    def __init__(self, A, intv, initialize = True):\n        # 1-indexed \n        self.N = len(A)\n        self.N0 = 2**(self.N-1).bit_length()\n        self.intv = intv\n        #self.segf = segf\n        self.lazy = [None]*(2*self.N0)\n        if initialize:\n            self.data = [intv]*self.N0 + A + [intv]*(self.N0 - self.N)\n            for i in range(self.N0-2, -1, -1):\n                self.data[i] = min(self.data[2*i], self.data[2*i+1]) \n        else:\n            self.data = [intv]*(2*self.N0)\n  \n    def _ascend(self, k):\n        k = k >> 1\n        c = k.bit_length()\n        for j in range(c):\n            idx = k >> j\n            self.data[idx] = min(self.data[2*idx], self.data[2*idx+1])\n              \n    def _descend(self, k):\n        k = k >> 1\n        idx = 1\n        c = k.bit_length()\n        for j in range(1, c+1):\n            idx = k >> (c - j)\n            if self.lazy[idx] is None:\n                continue\n            self.data[2*idx] = self.data[2*idx+1] = self.lazy[2*idx] \\\n            = self.lazy[2*idx+1] = self.lazy[idx] \n            self.lazy[idx] = None\n              \n              \n    def query(self, l, r):\n        L = l+self.N0\n        R = r+self.N0\n        self._descend(L//(L & -L))\n        self._descend(R//(R & -R) - 1)\n          \n        s = self.intv                                                                   \n  \n        while L < R:\n            if R & 1:\n                R -= 1\n                s = min(s, self.data[R])\n            if L & 1:\n                s = min(s, self.data[L])\n                L += 1\n            L >>= 1\n            R >>= 1\n        return s\n      \n    def update(self, l, r, x):\n        L = l+self.N0\n        R = r+self.N0\n  \n        Li = L//(L & -L)\n        Ri = R//(R & -R)\n        self._descend(Li)\n        self._descend(Ri-1)\n          \n        while L < R :\n            if R & 1:\n                R -= 1\n                self.data[R] = x\n                self.lazy[R] = x\n            if L & 1:\n                self.data[L] = x\n                self.lazy[L] = x\n                L += 1\n            L >>= 1\n            R >>= 1\n          \n        self._ascend(Li)\n        self._ascend(Ri-1)\n  \nN, Q = map(int, input().split())\nT = Lazysegtree([None]*N, 2**31-1, initialize = False) \nAns = []\nfor _ in range(Q):\n    t, *q = map(int, sys.stdin.readline().split())\n    q[1] += 1\n    if t:\n        Ans.append(T.query(*q))\n    else:\n        T.update(*q)\nprint('\\n'.join(map(str, Ans)))\n",
        "language": "python"
      },
      "dst": {
        "code": "class LazySegTree: # Non Recursion, RmQ, RUQ\n    def __init__(self, N):\n        self.N = N\n        self._N = 1<<((N-1).bit_length())\n        self.INF = (1<<31) - 1\n        self.node = [self.INF]*2*self._N\n        self.lazy = [None]*2*self._N\n\n    def build(self, lis):\n        for i in range(self.N):\n            self.node[i+self._N-1] = lis[i]\n        for i in range(self._N-2,-1,-1):\n            self.node[i] = self.node[i*2+1] + self.node[i*2+2]\n\n    def _gindex(self, l, r):\n        left = l + self._N; right = r + self._N\n        lm = (left // (left & -left)) >> 1\n        rm = (right // (right & -right)) >> 1\n        while left < right:\n            if right <= rm: yield right\n            if left <= lm: yield left\n            left >>= 1; right >>= 1\n        while left:\n            yield left\n            left >>= 1\n\n    def propagates(self, *ids): # ids: 1-indexded\n        for i in reversed(ids):\n            v = self.lazy[i-1]\n            if v is None: continue\n            self.lazy[2*i-1] = self.node[2*i-1] = v\n            self.lazy[2*i] = self.node[2*i] = v\n            self.lazy[i-1] = None\n        return\n\n    def update(self, l, r, x): # change all[left, right) to x\n        *ids, = self._gindex(l, r)\n        self.propagates(*ids)\n        left = l + self._N; right = r + self._N\n        while left < right:\n            if left & 1:\n                self.lazy[left-1] = self.node[left-1] = x\n                left += 1\n            if right & 1:\n                right -= 1\n                self.lazy[right-1] = self.node[right-1] = x\n            left >>= 1; right >>= 1\n        for i in ids:\n            self.node[i-1] = min(self.node[2*i-1], self.node[2*i])\n\n    def query(self, l, r):\n        self.propagates(*self._gindex(l, r))\n        left = l + self._N; right = r + self._N\n        ret = self.INF\n        while left < right:\n            if right & 1:\n                right -= 1\n                ret = min(ret, self.node[right-1])\n            if left & 1:\n                ret = min(ret, self.node[left-1])\n                left += 1\n            left >>= 1; right >>= 1\n        return ret\n\nnm = lambda: map(int, input().split())\nn,q = nm()\nS = LazySegTree(n)\nfor _ in range(q):\n  v = list(nm())\n  if v[0]:\n    # print(S.node)\n    # print(S.lazy)\n    print(S.query(v[1], v[2]+1))\n  else:\n  \tS.update(v[1], v[2]+1, v[3])\n",
        "language": "python"
      },
      "similarity": {
        "bleu": 0.3228381992054103,
        "jaccard": 0.42857142857142855,
        "tsed": 0.4108504398826977,
        "cged": 0.3952380952380953,
        "codebleu": 0.22340748914245812
      }
    },
    {
      "case": "p02350",
      "src": {
        "code": "import math\nfrom collections import deque\n\n\nclass SegmentTree:\n    __slots__ = [\"elem_size\", \"tree_size\", \"tree\", \"lazy\"]\n\n    def __init__(self, a: list, default: int):\n        real_size = len(a)\n        self.elem_size = 1 << math.ceil(math.log2(real_size))\n        self.tree_size = 2 * self.elem_size\n        self.tree = [default]*self.elem_size + a + [default]*(self.elem_size - real_size)\n        self.lazy = [None]*self.tree_size\n        self.init_tree()\n\n    def init_tree(self):\n        tree = self.tree\n        for i in range(self.elem_size-1, 0, -1):\n            left, right = tree[i << 1], tree[(i << 1)+1]\n            # ===== change me =====\n            tree[i] = left if left < right else right\n\n    def get_indexes(self, l: int, r: int):\n        '''[x, y)'''\n        l, r, targets, path, p_l, p_r = l+self.elem_size, r+self.elem_size, deque(), deque(), 0, 0\n        t_ap, p_ap = targets.append, path.appendleft\n\n        while l < r:\n            if l & 1:\n                t_ap(l)\n                p_l = p_l or l >> 1\n                l += 1\n            if r & 1:\n                r -= 1\n                t_ap(r)\n                p_r = p_r or r >> 1\n            l >>= 1\n            r >>= 1\n\n        deepest = (p_l, p_r)\n\n        while p_l > 1 or p_r > 1:\n            if p_r != p_l > 1:\n                p_ap(p_l)\n            p_l >>= 1\n            if p_r > 1:\n                p_ap(p_r)\n                p_r >>= 1\n\n        #print(targets, path)\n        return targets, path, deepest\n\n    def propagate(self, indexes: list, value: int = None):\n        tree, lazy, elem_size = self.tree, self.lazy, self.elem_size\n        if value is None:\n            for n in indexes:\n                if lazy[n] is None:\n                    continue\n                tree[n] = lazy[n]\n                if n < elem_size:\n                    lazy[n << 1] = lazy[(n << 1)+1] = lazy[n]\n                lazy[n] = None\n        else:\n            for n in indexes:\n                if n < elem_size:\n                    lazy[n << 1] = lazy[(n << 1)+1] = value\n                tree[n] = value\n                lazy[n] = None\n\n    def update_lazy(self, l, r, value):\n        targets, paths, deepest = self.get_indexes(l, r)\n        self.propagate(paths)\n        self.propagate(targets, value)\n        self.update_tree(deepest)\n\n    def get_value(self, l: int, r: int):\n        tree = self.tree\n        targets, paths, deepest = self.get_indexes(l, r)\n        self.propagate(paths)\n        self.propagate(targets)\n        self.update_tree(deepest)\n\n        # ===== change me =====\n        return min(tree[n] for n in targets)\n\n    def update_tree(self, indexes: tuple):\n        ''' ????????????lazy??????????????????????????????????????????????????????? '''\n\n        tree, lazy = self.tree, self.lazy\n\n        for k in indexes:\n            #if k >= self.elem_size:\n            #    k >>= 1\n\n            while k > 0:\n                left, right = k << 1, (k << 1)+1\n                # ===== change me =====\n                if lazy[left] is not None:\n                    tree[left] = lazy[left]\n                if lazy[right] is not None:\n                    tree[right] = lazy[right]\n                tree[k] = tree[left] if tree[left] < tree[right] else tree[right]\n\n                k >>= 1\n\n    def set_value(self, i: int, value: int, op: str):\n        k = self.elem_size + i\n        if op == \"=\":\n            self.tree[k] = value\n        elif op == \"+\":\n            self.tree[k] += value\n        self.update_tree(k)\n\n\nn, q = map(int, input().split())\nrmq = SegmentTree([2**31-1]*n, 2**31-1)\nans = []\nappend = ans.append\nfor _ in [0]*q:\n    l = list(map(int, input().split()))\n    if l[0] == 0:\n        rmq.update_lazy(l[1], l[2]+1, l[3])\n    else:\n        a = rmq.get_value(l[1], l[2]+1)\n        append(a)\n\nprint(\"\\n\".join([str(n) for n in ans]))",
        "language": "python"
      },
      "dst": {
        "code": "import sys\nreadline = sys.stdin.readline\nwrite = sys.stdout.write\n\nN, Q = map(int, input().split())\nINF = 2**31-1\n\nLV = (N-1).bit_length()\nN0 = 2**LV\ndata = [INF]*(2*N0)\nlazy = [None]*(2*N0)\n\ndef gindex(l, r):\n    L = l + N0; R = r + N0\n    lm = (L // (L & -L)) >> 1\n    rm = (R // (R & -R)) >> 1\n    while L < R:\n        if R <= rm:\n            yield R\n        if L <= lm:\n            yield L\n        L >>= 1; R >>= 1\n    while L:\n        yield L\n        L >>= 1\n\ndef propagates(*ids):\n    for i in reversed(ids):\n        v = lazy[i-1]\n        if v is None:\n            continue\n        lazy[2*i-1] = data[2*i-1] = lazy[2*i] = data[2*i] = v\n        lazy[i-1] = None\n\ndef update(l, r, x):\n    *ids, = gindex(l, r)\n    propagates(*ids)\n\n    L = N0 + l; R = N0 + r\n    while L < R:\n        if R & 1:\n            R -= 1\n            lazy[R-1] = data[R-1] = x\n        if L & 1:\n            lazy[L-1] = data[L-1] = x\n            L += 1\n        L >>= 1; R >>= 1\n    for i in ids:\n        data[i-1] = min(data[2*i-1], data[2*i])\n\ndef query(l, r):\n    propagates(*gindex(l, r))\n    L = N0 + l; R = N0 + r\n\n    s = INF\n    while L < R:\n        if R & 1:\n            R -= 1\n            s = min(s, data[R-1])\n        if L & 1:\n            s = min(s, data[L-1])\n            L += 1\n        L >>= 1; R >>= 1\n    return s\n\n\nans = []\nfor q in range(Q):\n    t, *cmd = map(int, readline().split())\n    if t:\n        s, t = cmd\n        ans.append(str(query(s, t+1)))\n    else:\n        s, t, x = cmd\n        update(s, t+1, x)\n\nwrite(\"\\n\".join(ans))\nwrite(\"\\n\")\n",
        "language": "python"
      },
      "similarity": {
        "bleu": 0.13010104623997393,
        "jaccard": 0.35384615384615387,
        "tsed": 0.27499999999999986,
        "cged": 0.0,
        "codebleu": 0.17164085103602938
      }
    },
    {
      "case": "p02350",
      "src": {
        "code": "#!/usr/bin/env python3\n\n# from collections import defaultdict\n# from heapq import heappush, heappop\n# import numpy as np\nimport sys\n\ntry:\n    profile\nexcept:\n    def profile(f): return f\n\n\ndef set_depth(depth):\n    global DEPTH, SEGTREE_SIZE, NONLEAF_SIZE\n    DEPTH = depth\n    SEGTREE_SIZE = 1 << DEPTH\n    NONLEAF_SIZE = 1 << (DEPTH - 1)\n\n\ndef set_width(width):\n    set_depth((width - 1).bit_length() + 1)\n\n\n@profile\ndef force_point(value_table, action_table, pos, action_force, action_composite, action_unity):\n    action = action_table[pos]\n    if action != action_unity:\n        value_table[pos] = action\n\n        if pos < NONLEAF_SIZE:\n            action_table[pos * 2] = action\n            action_table[pos * 2 + 1] = action\n    action_table[pos] = action_unity\n\n\ndef force_down_propagate(action_table, value_table, pos, action_composite, action_force, action_unity):\n    max_level = pos.bit_length() - 1\n\n    for level in range(max_level):\n        i = pos >> (max_level - level)\n        action = action_table[i]\n        if action != action_unity:\n            action_table[i * 2] = action_composite(action, action_table[i * 2])\n            action_table[i * 2 +\n                         1] = action_composite(action, action_table[i * 2 + 1])\n            action_table[i] = action_unity\n            value_table[i * 2] = action\n            value_table[i * 2 + 1] = action\n\n\ndef down_propagate_target(pos):\n    max_level = pos.bit_length() - 1\n\n    for level in range(max_level):\n        i = pos >> (max_level - level)\n        yield i\n\n\n@profile\ndef force_range_update(value_table, action_table, left, right, action, action_force, action_composite, action_unity):\n    \"\"\"\n    action_force: action, value, cell_size => new_value\n    action_composite: new_action, old_action => composite_action\n    \"\"\"\n    left += NONLEAF_SIZE\n    right += NONLEAF_SIZE\n    while left < right:\n        if left & 1:\n            value_table[left] = action\n            action_table[left] = action\n            left += 1\n        if right & 1:\n            right -= 1\n            value_table[right] = action\n            action_table[right] = action\n\n        left //= 2\n        right //= 2\n\n\n@profile\ndef range_reduce(table, left, right, binop, unity):\n    ret_left = unity\n    ret_right = unity\n    left += NONLEAF_SIZE\n    right += NONLEAF_SIZE\n    while left < right:\n        if left & 1:\n            ret_left = binop(ret_left, table[left])\n            left += 1\n        if right & 1:\n            right -= 1\n            ret_right = binop(table[right], ret_right)\n\n        left //= 2\n        right //= 2\n    return binop(ret_left, ret_right)\n\n\n@profile\ndef up_prop_force(value_table, action_table, pos, binop, action_force, action_composite, action_unity):\n    \"\"\"\n    force_children + up_propagation\n    \"\"\"\n    while pos > 1:\n        pos >>= 1\n        force_point(\n            value_table, action_table,\n            pos * 2, action_force, action_composite, action_unity)\n\n        force_point(\n            value_table, action_table,\n            pos * 2 + 1, action_force, action_composite, action_unity)\n        value_table[pos] = binop(\n            value_table[pos * 2],\n            value_table[pos * 2 + 1]\n        )\n\n\ndef up_propagate(table, pos, binop):\n    while pos > 1:\n        pos >>= 1\n        table[pos] = binop(\n            table[pos * 2],\n            table[pos * 2 + 1]\n        )\n\n\ndef up(pos):\n    pos += SEGTREE_SIZE // 2\n    return pos // (pos & -pos)\n\n\ndef lazy_range_update(\n        action_table, value_table, start, end,\n        action, action_composite, action_force, action_unity, value_binop):\n    \"update [start, end)\"\n    L = up(start)\n    R = up(end)\n    force_down_propagate(\n        action_table, value_table, L,\n        action_composite, action_force, action_unity)\n    force_down_propagate(\n        action_table, value_table, R,\n        action_composite, action_force, action_unity)\n    force_range_update(\n        value_table, action_table, start, end,\n        action, action_force, action_composite, action_unity)\n    up_propagate(value_table, L, value_binop)\n    up_propagate(value_table, R, value_binop)\n\n\ndef lazy_range_reduce(\n    action_table, value_table, start, end,\n    action_composite, action_force, action_unity,\n    value_binop, value_unity\n):\n    \"reduce [start, end)\"\n\n    force_down_propagate(\n        action_table, value_table, up(start),\n        action_composite, action_force,  action_unity)\n    force_down_propagate(\n        action_table, value_table, up(end),\n        action_composite, action_force, action_unity)\n\n    return range_reduce(value_table, start, end, value_binop, value_unity)\n\n\ndef debugprint(xs, minsize=0, maxsize=None):\n    global DEPTH\n    strs = [str(x) for x in xs]\n    if maxsize != None:\n        for i in range(NONLEAF_SIZE, SEGTREE_SIZE):\n            strs[i] = strs[i][:maxsize]\n    s = max(len(s) for s in strs[NONLEAF_SIZE:])\n    if s > minsize:\n        minsize = s\n\n    result = [\"|\"] * DEPTH\n    level = 0\n    next_level = 2\n    for i in range(1, SEGTREE_SIZE):\n        if i == next_level:\n            level += 1\n            next_level *= 2\n        width = ((minsize + 1) << (DEPTH - 1 - level)) - 1\n        result[level] += strs[i].center(width) + \"|\"\n    print(*result, sep=\"\\n\")\n\n\ndef main():\n    N, Q = map(int, input().split())\n    set_width(N)\n\n    value_unity = (1 << 31) - 1\n    value_table = [value_unity] * SEGTREE_SIZE\n    action_unity = -1\n    action_table = [action_unity] * SEGTREE_SIZE\n\n    action_force = None\n\n    def action_composite(new_action, old_action):\n        return new_action\n\n    for _ in range(Q):\n        q, *args = map(int, input().split())\n        if q == 0:\n            # update\n            s, t, value = args\n            lazy_range_update(\n                action_table, value_table, s, t + 1, value,\n                action_composite, action_force, action_unity, min)\n        else:\n            # find\n            s, t = args\n            print(lazy_range_reduce(\n                action_table, value_table, s, t + 1,\n                action_composite, action_force, action_unity, min, value_unity))\n        # debugprint(action_table)\n        # debugprint(value_table)\n\n\nT1 = \"\"\"\n3 5\n0 0 1 1\n0 1 2 3\n0 2 2 2\n1 0 2\n1 1 2\n\"\"\"\nTEST_T1 = \"\"\"\n>>> as_input(T1)\n>>> main()\n1\n2\n\"\"\"\nT2 = \"\"\"\n1 3\n1 0 0\n0 0 0 5\n1 0 0\n\"\"\"\nTEST_T2 = \"\"\"\n>>> as_input(T2)\n>>> main()\n2147483647\n5\n\"\"\"\nT3 = \"\"\"\n8 10\n0 1 6 5\n0 2 7 2\n0 2 5 7\n1 3 3\n1 2 4\n1 0 3\n1 5 7\n1 2 6\n0 3 7 9\n1 2 6\n\"\"\"\nTEST_T3 = \"\"\"\n>>> as_input(T3)\n>>> main()\n7\n7\n5\n2\n2\n7\n\"\"\"\nT4 = \"\"\"\n15 3\n0 1 6 5\n0 2 7 2\n1 6 7\n\"\"\"\nTEST_T4 = \"\"\"\n>>> as_input(T4)\n>>> main()\n2\n\"\"\"\n\n\ndef _test():\n    import doctest\n    doctest.testmod()\n    g = globals()\n    for k in sorted(g):\n        if k.startswith(\"TEST_\"):\n            doctest.run_docstring_examples(g[k], g)\n\n\ndef as_input(s):\n    \"use in test, use given string as input file\"\n    import io\n    global read, input\n    f = io.StringIO(s.strip())\n\n    def input():\n        return bytes(f.readline(), \"ascii\")\n\n    def read():\n        return bytes(f.read(), \"ascii\")\n\n\nif sys.argv[-1] == \"-t\":\n    print(\"testing\")\n    _test()\n    sys.exit()\n\nmain()\n\n",
        "language": "python"
      },
      "dst": {
        "code": "import sys\ninput=sys.stdin.readline\n\ndef gindex(l,r):\n    L,R=l+N0,r+N0\n    lm=L//(L&-L)>>1\n    rm=R//(R&-R)>>1\n    while L<R:\n        if R<=rm:\n            yield R\n        if L<=lm:\n            yield L\n        L>>=1\n        R>>=1\n    while L:\n        yield L\n        L>>=1\ndef propagates(*ids):\n    for i in reversed(ids):\n        v=lazy[i-1]\n        if v==None:\n            continue\n        lazy[2*i-1]=v\n        lazy[2*i]=v\n        data[2*i-1]=v\n        data[2*i]=v\n        lazy[i-1]=None\ndef update(l,r,x):#1-index [s,t)\n    L,R=N0+l,N0+r\n    *ids,=gindex(l,r)\n    propagates(*ids)\n    while L<R:#\n        if R&1:\n            R-=1\n            lazy[R-1]=x\n            data[R-1]=x\n        if L&1:\n            lazy[L-1]=x\n            data[L-1]=x\n            L+=1\n        L>>=1\n        R>>=1\n    for i in ids:#\n        data[i-1]=min(data[2*i-1],data[2*i])\ndef query(l,r):\n    propagates(*gindex(l,r))\n    L,R=N0+l,N0+r\n    s=INF\n    while L<R:\n        if R&1:\n            R-=1\n            s=min(s,data[R-1])\n        if L&1:\n            s=min(s,data[L-1])\n            L+=1\n        L>>=1\n        R>>=1\n    return s\nn,q=map(int,input().split())\n\nLV=n.bit_length()\nN0=2**LV\nINF=2**40\ndata=[2**31-1]*2*N0\nlazy=[None]*2*N0\nfor i in range(q):\n    l=list(map(int,input().split()))\n    if l[0]==0:\n        s,t,x=l[1:]\n        update(s,t+1,x)\n    else:\n        s,t=l[1:]\n        print(query(s,t+1))\n\n",
        "language": "python"
      },
      "similarity": {
        "bleu": 0.07932795639285908,
        "jaccard": 0.245,
        "tsed": 0.23640897755611057,
        "cged": 0.0,
        "codebleu": 0.24201918636182101
      }
    },
    {
      "case": "p02350",
      "src": {
        "code": "from math import log2, ceil\n\n\nclass SegmentTree:\n    def __init__(self, n):\n        tn = 2 ** ceil(log2(n))\n        self.a = [2 ** 31 - 1] * (tn * 2)\n        self.l = tn * 2\n        self.tn = tn\n\n    def find(self, c, l, r, s, t):\n        if self.a[c] == -1:\n            return self.a[c // 2]\n        if s <= l and r <= t:\n            return self.a[c]\n        mid = (l + r) // 2\n        if t <= mid:\n            return self.find(c * 2, l, mid, s, t)\n        elif s > mid:\n            return self.find(c * 2 + 1, mid + 1, r, s, t)\n        else:\n            return min(\n                self.find(c * 2, l, mid, s, mid),\n                self.find(c * 2 + 1, mid + 1, r, mid + 1, t))\n\n    def update(self, c, l, r, s, t, x, f=None):\n\n        if f is None and self.a[c] == -1:\n            f = self.a[c // 2]\n\n        if l == s and r == t:\n            return self.set(c, x)\n\n        mid = (l + r) // 2\n        if t <= mid:\n            rv, f = self.get_child(c, c * 2 + 1, f)\n            u = min(self.update(c * 2, l, mid, s, t, x, f), rv)\n        elif s > mid:\n            lv, f = self.get_child(c, c * 2, f)\n            u = min(lv, self.update(c * 2 + 1, mid + 1, r, s, t, x, f))\n        else:\n            u = min(\n                self.update(c * 2, l, mid, s, mid, x, f),\n                self.update(c * 2 + 1, mid + 1, r, mid + 1, t, x, f))\n            if f is not None:\n                u = min(f, u)\n        self.a[c] = u\n\n        return u\n\n    def set(self, c, x):\n        self.a[c] = x\n        if c * 2 < self.l:\n            self.a[c * 2] = self.a[c * 2 + 1] = -1\n        return x\n\n    def get_child(self, c, child, f):\n        if f is not None:\n            return self.set(child, f), f\n        v = self.a[child]\n        if v == -1:\n            f = self.a[c]\n            v = self.set(child, f)\n        return v, f\n\n\nn, q = map(int, input().split())\nst = SegmentTree(n)\nbuf = []\nfor _ in range(q):\n    query = input().split()\n    if query[0] == '0':\n        s, t, x = map(int, query[1:])\n        st.update(1, 0, st.tn - 1, s, t, x)\n    else:\n        s, t = map(int, query[1:])\n        buf.append(st.find(1, 0, st.tn - 1, s, t))\n        # print(_, query, st.a)\nprint('\\n'.join(map(str, buf)))",
        "language": "python"
      },
      "dst": {
        "code": "import math\n\n\nclass SegmentTree:\n    __slots__ = [\"rank\", \"elem_size\", \"tree_size\", \"tree\", \"lazy\", \"default_value\"]\n\n    def __init__(self, a: list, default: int):\n        self.default_value = default\n        real_size = len(a)\n        self.rank = math.ceil(math.log2(real_size))\n        self.elem_size = 1 << self.rank\n        self.tree_size = 2 * self.elem_size\n        self.tree = [default]*self.elem_size + a + [default]*(self.elem_size - real_size)\n        self.lazy = [None]*self.tree_size\n        # self.init_tree()\n\n    def init_tree(self):\n        tree = self.tree\n        for i in range(self.elem_size-1, 0, -1):\n            left, right = tree[i << 1], tree[(i << 1)+1]\n            # ===== change me =====\n            tree[i] = left if left < right else right\n\n    def process_query(self, l: int, r: int, value: int = None):\n        '''[x, y)'''\n        tree, lazy, elem_size, rank = self.tree, self.lazy, self.elem_size, self.rank-1\n        l, r, targets, p_l, p_r, l_rank, r_rank = l+elem_size, r+elem_size, [], 0, 0, 0, 0\n        t_ap = targets.append\n\n        while l < r:\n            if l & 1:\n                t_ap(l)\n                p_l = p_l or l >> 1\n                l_rank = l_rank or rank\n                l += 1\n            if r & 1:\n                r -= 1\n                t_ap(r)\n                p_r = p_r or r >> 1\n                r_rank = r_rank or rank\n            l >>= 1\n            r >>= 1\n            rank -= 1\n\n        deepest = (p_l, p_r)\n\n        paths = [[p_l >> n for n in range(l_rank-1, -1, -1)], [p_r >> n for n in range(r_rank-1, -1, -1)]]\n\n        for a in paths:\n            for i in a:\n                if lazy[i] is None:\n                    continue\n                # ===== change me =====\n                tree[i] = lazy[i]\n                if i < elem_size:\n                    lazy[i << 1] = lazy[i]\n                    lazy[(i << 1)+1] = lazy[i]\n                lazy[i] = None\n\n        result = self.default_value\n        for i in targets:\n            v = value if value is not None else lazy[i]\n            # ===== change me =====\n            if v is not None:\n                if i < elem_size:\n                    lazy[i << 1] = v\n                    lazy[(i << 1)+1] = v\n                tree[i] = v\n                lazy[i] = None\n            if result > tree[i]:\n                result = tree[i]\n\n        self.update_tree(deepest)\n\n        return result\n\n    def update_tree(self, indexes: tuple):\n        ''' ????????????lazy??????????????????????????????????????????????????????? '''\n\n        tree, lazy = self.tree, self.lazy\n\n        for k in indexes:\n            while k > 0:\n                left, right = k << 1, (k << 1)+1\n                # ===== change me =====\n                l_value = tree[left] if lazy[left] is None else lazy[left]\n                r_value = tree[right] if lazy[right] is None else lazy[right]\n                tree[k] = l_value if l_value < r_value else r_value\n\n                k >>= 1\n\n\nn, q = map(int, input().split())\nrmq = SegmentTree([2**31-1]*n, 2**31-1)\nans = []\nappend = ans.append\nfor _ in [0]*q:\n    l = list(map(int, input().split()))\n    if l[0] == 0:\n        rmq.process_query(l[1], l[2]+1, l[3])\n    else:\n        a = rmq.process_query(l[1], l[2]+1)\n        append(a)\n\nprint(\"\\n\".join([str(n) for n in ans]))",
        "language": "python"
      },
      "similarity": {
        "bleu": 0.1596685294914375,
        "jaccard": 0.452991452991453,
        "tsed": 0.3115537848605555,
        "cged": 0.0,
        "codebleu": 0.1579369295272241
      }
    },
    {
      "case": "p02350",
      "src": {
        "code": "from math import log2, ceil\n\n\nclass SegmentTree:\n    def __init__(self, n):\n        tn = 2 ** ceil(log2(n))\n        self.a = [2 ** 31 - 1] * (tn * 2)\n        self.l = tn * 2\n        self.tn = tn\n\n    def find(self, c, l, r, s, t):\n        if self.a[c] == -1:\n            return self.a[c // 2]\n        if s <= l and r <= t:\n            return self.a[c]\n        mid = (l + r) // 2\n        if t <= mid:\n            return self.find(c * 2, l, mid, s, t)\n        elif s > mid:\n            return self.find(c * 2 + 1, mid + 1, r, s, t)\n        else:\n            return min(\n                self.find(c * 2, l, mid, s, mid),\n                self.find(c * 2 + 1, mid + 1, r, mid + 1, t))\n\n    def update(self, c, l, r, s, t, x, f=None):\n\n        if f is None and self.a[c] == -1:\n            f = self.a[c // 2]\n\n        if l == s and r == t:\n            return self.set(c, x)\n\n        mid = (l + r) // 2\n        if t <= mid:\n            rv, f = self.get_child(c, c * 2 + 1, f)\n            u = min(self.update(c * 2, l, mid, s, t, x, f), rv)\n        elif s > mid:\n            lv, f = self.get_child(c, c * 2, f)\n            u = min(lv, self.update(c * 2 + 1, mid + 1, r, s, t, x, f))\n        else:\n            u = min(\n                self.update(c * 2, l, mid, s, mid, x, f),\n                self.update(c * 2 + 1, mid + 1, r, mid + 1, t, x, f))\n            if f is not None:\n                u = min(f, u)\n        self.a[c] = u\n\n        return u\n\n    def set(self, c, x):\n        self.a[c] = x\n        if c * 2 < self.l:\n            self.a[c * 2] = self.a[c * 2 + 1] = -1\n        return x\n\n    def get_child(self, c, child, f):\n        if f is not None:\n            return self.set(child, f), f\n        v = self.a[child]\n        if v == -1:\n            f = self.a[c]\n            v = self.set(child, f)\n        return v, f\n\n\nn, q = map(int, input().split())\nst = SegmentTree(n)\nbuf = []\nfor _ in range(q):\n    query = input().split()\n    if query[0] == '0':\n        s, t, x = map(int, query[1:])\n        st.update(1, 0, st.tn - 1, s, t, x)\n    else:\n        s, t = map(int, query[1:])\n        buf.append(st.find(1, 0, st.tn - 1, s, t))\n        # print(_, query, st.a)\nprint('\\n'.join(map(str, buf)))",
        "language": "python"
      },
      "dst": {
        "code": "from collections import defaultdict,deque\nimport sys,heapq,bisect,math,itertools,string,queue,copy,time\nsys.setrecursionlimit(10**8)\nINF = float('inf')\nmod = 10**9+7\neps = 10**-7\nprint = sys.stdout.write\ndef inp(): return int(sys.stdin.readline())\ndef inpl(): return list(map(int, sys.stdin.readline().split()))\ndef inpl_str(): return list(sys.stdin.readline().split())\n\nclass SegmentTree:\n    def __init__(self,N,d):\n        self.N0 = 2**(N-1).bit_length()\n        self.node = [d]*(self.N0*2)\n        self.lazy = [None]*(self.N0*2)\n\n    def gindex(self,l,r):\n        L = l + self.N0\n        R = r + self.N0\n        lm = (L // (L & -L)) >> 1\n        rm = (R // (R & -R)) >> 1\n        while L < R:\n            if R <= rm:\n                yield R\n            if L <= lm:\n                yield L\n            L >>= 1; R >>= 1\n        while L:\n            yield L\n            L >>= 1\n\n    def propagates(self,*ids):\n        for i in reversed(ids):\n            v = self.lazy[i-1]\n            if v is None:\n                continue\n            self.lazy[2*i-1] = self.lazy[2*i] = v\n            self.node[2*i-1] = self.node[2*i] = v\n            self.lazy[i-1] = None\n\n    def update(self,l,r,x): #ix\n        *ids, = self.gindex(l, r)\n\n        # lazy\n        self.propagates(*ids)\n\n        # [l, r)node, lazy\n        L = self.N0 + l\n        R = self.N0 + r\n        while L < R:\n            if R & 1:\n                R -= 1\n                self.lazy[R-1] = self.node[R-1] = x\n            if L & 1:\n                self.lazy[L-1] = self.node[L-1] = x\n                L += 1\n            L >>= 1; R >>= 1\n\n        # node\n        for i in ids:\n            self.node[i-1] = self.process(self.node[2*i-1], self.node[2*i])\n\n    def query(self,l, r):\n        # lazy\n        self.propagates(*self.gindex(l, r))\n        L = self.N0 + l\n        R = self.N0 + r\n\n        # [l, r)\n        s = INF\n        while L < R:\n            if R & 1:\n                R -= 1\n                s = self.process(s, self.node[R-1])\n            if L & 1:\n                s = self.process(s, self.node[L-1])\n                L += 1\n            L >>= 1; R >>= 1\n        return s\n\n    def process(self,x,y): #x,y\n        return min(x,y)\n\nN,Q = inpl()\nST = SegmentTree(N,2**31-1)\nans = []\nfor _ in range(Q):\n    c,*arg = inpl()\n    if c:\n        s,t = arg\n        ans.append(str(ST.query(s,t+1)))\n    else:\n        s,t,x = arg\n        ST.update(s,t+1,x)\n\nprint('\\n'.join(ans))\nprint('\\n')\n\n",
        "language": "python"
      },
      "similarity": {
        "bleu": 0.19606918293815262,
        "jaccard": 0.38571428571428573,
        "tsed": 0.30934065934065724,
        "cged": 0.0,
        "codebleu": 0.1529076462732904
      }
    },
    {
      "case": "p02350",
      "src": {
        "code": "import sys\ninput = sys.stdin.readline\nINF = 2**31 - 1\n\nclass LazySegmentTree:\n    def __init__(self, n):\n        LV = (n-1).bit_length()\n        self.N0 = 2 ** LV\n        self.data = [INF] * (2*self.N0)\n        self.lazy = [None] * (2*self.N0)\n        \n    def gindex(self, l, r):\n        L = l + self.N0; R = r + self.N0\n        lm = (L // (L & -L)) >> 1\n        rm = (R // (R & -R)) >> 1\n    \n        while L < R:\n            if R <= rm:\n                yield R\n            if L <= lm:\n                yield L\n            \n            L >>= 1; R >>= 1\n        \n        while L:\n            yield L\n            L >>= 1\n\n    def propagates(self, *ids):\n        for i in reversed(ids):\n            v = self.lazy[i-1]\n            \n            if v is None:\n                continue\n            \n            self.lazy[2*i-1] = self.data[2*i-1] = self.lazy[2*i] = self.data[2*i] = v\n            self.lazy[i-1] = None\n\n    def update(self, l, r, x):\n        *ids, = self.gindex(l, r)\n        self.propagates(*ids)\n\n        L = self.N0 + l; R = self.N0 + r\n        \n        while L < R:\n            if R & 1:\n                R -= 1\n                self.lazy[R-1] = self.data[R-1] = x\n            if L & 1:\n                self.lazy[L-1] = self.data[L-1] = x\n                L += 1\n                \n            L >>= 1; R >>= 1\n            \n        for i in ids:\n            self.data[i-1] = min(self.data[2*i-1], self.data[2*i])\n\n    def query(self, l, r):\n        self.propagates(*self.gindex(l, r))\n        L = self.N0 + l; R = self.N0 + r\n\n        s = INF\n        \n        while L < R:\n            if R & 1:\n                R -= 1\n                s = min(s, self.data[R-1])\n            if L & 1:\n                s = min(s, self.data[L-1])\n                L += 1\n                \n            L >>= 1; R >>= 1\n            \n        return s\n\nn, q = map(int, input().split())\nlst = LazySegmentTree(n)\n\nfor _ in range(q):\n    que = list(map(int, input().split()))\n    \n    if que[0] == 0:\n        s, t, x = que[1], que[2], que[3]\n        lst.update(s, t+1, x)\n    elif que[0] == 1:\n        s, t = que[1], que[2]\n        print(lst.query(s, t+1))\n",
        "language": "python"
      },
      "dst": {
        "code": "import sys\ninput = sys.stdin.readline\n\nN,Q=map(int,input().split())\n\nseg_el=1<<(N.bit_length()) # Segment tree\nSEG=[(1<<31)-1]*(2*seg_el) # 1-indexed2*seg_el.Segment tree\nLAZY=[None]*(2*seg_el) # 1-indexed2*seg_el.Segment tree\n\n\ndef indexes(L,R):\n    INDLIST=[]\n\n    R-=1\n    \n    L>>=1\n    R>>=1\n\n    while L!=R:\n        if L>R:\n            INDLIST.append(L)\n            L>>=1\n        else:\n            INDLIST.append(R)\n            R>>=1\n\n    while L!=0:\n        INDLIST.append(L)\n        L>>=1\n\n    return INDLIST\n        \n\ndef updates(l,r,x): # [l,r)x\n        \n    L=l+seg_el\n    R=r+seg_el\n\n    L//=(L & (-L))\n    R//=(R & (-R))\n\n    UPIND=indexes(L,R)\n    \n    for ind in UPIND[::-1]:\n        if LAZY[ind]!=None:\n            LAZY[ind<<1]=LAZY[1+(ind<<1)]=SEG[ind<<1]=SEG[1+(ind<<1)]=LAZY[ind]\n            LAZY[ind]=None\n    \n    while L!=R:\n        if L > R:\n            SEG[L]=x\n            LAZY[L]=x\n            L+=1\n            L//=(L & (-L))\n\n        else:\n            R-=1\n            SEG[R]=x\n            LAZY[R]=x\n            R//=(R & (-R))\n\n    for ind in UPIND:\n        SEG[ind]=min(SEG[ind<<1],SEG[1+(ind<<1)])  \n        \ndef getvalues(l,r): # [l,r)min\n\n    L=l+seg_el\n    R=r+seg_el\n\n    L//=(L & (-L))\n    R//=(R & (-R))\n\n    UPIND=indexes(L,R)\n    \n    for ind in UPIND[::-1]:\n        if LAZY[ind]!=None:\n            LAZY[ind<<1]=LAZY[1+(ind<<1)]=SEG[ind<<1]=SEG[1+(ind<<1)]=LAZY[ind]\n            LAZY[ind]=None\n            \n    ANS=1<<31\n\n    while L!=R:\n        if L > R:\n            ANS=min(ANS , SEG[L])\n            L+=1\n            L//=(L & (-L))\n\n        else:\n            R-=1\n            ANS=min(ANS , SEG[R])\n            R//=(R & (-R))\n\n    return ANS\n\nANS=[]\n\nfor _ in range(Q):\n    query=list(map(int,input().split()))\n    if query[0]==0:\n        updates(query[1],query[2]+1,query[3])\n\n    else:\n        ANS.append(getvalues(query[1],query[2]+1))\n\n\nprint(\"\\n\".join([str(ans) for ans in ANS]))\n\n",
        "language": "python"
      },
      "similarity": {
        "bleu": 0.27266429625163363,
        "jaccard": 0.46153846153846156,
        "tsed": 0.3119999999999991,
        "cged": 0.0,
        "codebleu": 0.18995934599036748
      }
    },
    {
      "case": "p02350",
      "src": {
        "code": "import math\nfrom collections import deque\n\n\nclass SegmentTree:\n    __slots__ = [\"elem_size\", \"tree_size\", \"tree\", \"lazy\"]\n\n    def __init__(self, a: list, default: int):\n        real_size = len(a)\n        self.elem_size = 1 << math.ceil(math.log2(real_size))\n        self.tree_size = 2 * self.elem_size\n        self.tree = [default]*self.elem_size + a + [default]*(self.elem_size - real_size)\n        self.lazy = [None]*self.tree_size\n        self.init_tree()\n\n    def init_tree(self):\n        tree = self.tree\n        for i in range(self.elem_size-1, 0, -1):\n            left, right = tree[i << 1], tree[(i << 1)+1]\n            # ===== change me =====\n            tree[i] = left if left < right else right\n\n    def get_indexes(self, l: int, r: int):\n        '''[x, y)'''\n        l, r, targets, path, p_l, p_r = l+self.elem_size, r+self.elem_size, deque(), deque(), 0, 0\n        t_ap, p_ap = targets.append, path.appendleft\n\n        while l < r:\n            if l & 1:\n                t_ap(l)\n                p_l = p_l or l >> 1\n                l += 1\n            if r & 1:\n                r -= 1\n                t_ap(r)\n                p_r = p_r or r >> 1\n            l >>= 1\n            r >>= 1\n\n        deepest = (p_l, p_r)\n\n        while p_l > 1 or p_r > 1:\n            if p_r != p_l > 1:\n                p_ap(p_l)\n            p_l >>= 1\n            if p_r > 1:\n                p_ap(p_r)\n                p_r >>= 1\n\n        #print(targets, path)\n        return targets, path, deepest\n\n    def propagate(self, indexes: list, value: int = None):\n        tree, lazy, elem_size = self.tree, self.lazy, self.elem_size\n        if value is None:\n            for n in indexes:\n                if lazy[n] is None:\n                    continue\n                tree[n] = lazy[n]\n                if n < elem_size:\n                    lazy[n << 1] = lazy[(n << 1)+1] = lazy[n]\n                lazy[n] = None\n        else:\n            for n in indexes:\n                if n < elem_size:\n                    lazy[n << 1] = lazy[(n << 1)+1] = value\n                tree[n] = value\n                lazy[n] = None\n\n    def update_lazy(self, l, r, value):\n        targets, paths, deepest = self.get_indexes(l, r)\n        self.propagate(paths)\n        self.propagate(targets, value)\n        self.update_tree(deepest)\n\n    def get_value(self, l: int, r: int):\n        tree = self.tree\n        targets, paths, deepest = self.get_indexes(l, r)\n        self.propagate(paths)\n        self.propagate(targets)\n        self.update_tree(deepest)\n\n        # ===== change me =====\n        return min(tree[n] for n in targets)\n\n    def update_tree(self, indexes: tuple):\n        ''' ????????????lazy??????????????????????????????????????????????????????? '''\n\n        tree, lazy = self.tree, self.lazy\n\n        for k in indexes:\n            #if k >= self.elem_size:\n            #    k >>= 1\n\n            while k > 0:\n                left, right = k << 1, (k << 1)+1\n                # ===== change me =====\n                if lazy[left] is not None:\n                    tree[left] = lazy[left]\n                if lazy[right] is not None:\n                    tree[right] = lazy[right]\n                tree[k] = tree[left] if tree[left] < tree[right] else tree[right]\n\n                k >>= 1\n\n    def set_value(self, i: int, value: int, op: str):\n        k = self.elem_size + i\n        if op == \"=\":\n            self.tree[k] = value\n        elif op == \"+\":\n            self.tree[k] += value\n        self.update_tree(k)\n\n\nn, q = map(int, input().split())\nrmq = SegmentTree([2**31-1]*n, 2**31-1)\nans = []\nappend = ans.append\nfor _ in [0]*q:\n    l = list(map(int, input().split()))\n    if l[0] == 0:\n        rmq.update_lazy(l[1], l[2]+1, l[3])\n    else:\n        a = rmq.get_value(l[1], l[2]+1)\n        append(a)\n\nprint(\"\\n\".join([str(n) for n in ans]))",
        "language": "python"
      },
      "dst": {
        "code": "import math\nfrom collections import deque\n\n\nclass SegmentTree:\n    __slots__ = [\"elem_size\", \"tree_size\", \"tree\", \"lazy\"]\n\n    def __init__(self, a: list, default: int):\n        real_size = len(a)\n        self.elem_size = 1 << math.ceil(math.log2(real_size))\n        self.tree_size = 2 * self.elem_size\n        self.tree = [default]*self.elem_size + a + [default]*(self.elem_size - real_size)\n        self.lazy = [None]*self.tree_size\n        self.init_tree()\n\n    def init_tree(self):\n        tree = self.tree\n        for i in range(self.elem_size-1, 0, -1):\n            left, right = tree[i << 1], tree[(i << 1)+1]\n            # ===== change me =====\n            tree[i] = left if left < right else right\n\n    def get_indexes(self, l: int, r: int):\n        '''[x, y)'''\n        l, r, targets, path, p_l, p_r, = l+self.elem_size, r+self.elem_size, deque(), deque(), 0, 0\n        t_ap, p_ap = targets.append, path.appendleft\n\n        while l < r:\n            if l & 1:\n                t_ap(l)\n                p_l = p_l or l >> 1\n                l += 1\n            if r & 1:\n                r -= 1\n                t_ap(r)\n                p_r = p_r or r >> 1\n            l, r = l >> 1, r >> 1\n\n        deepest = (p_l, p_r)\n\n        while p_l > 1 or p_r > 1:\n            if p_l > 1:\n                p_ap(p_l)\n            if p_l != p_r > 1:\n                p_ap(p_r)\n            p_l >>= 1\n            p_r >>= 1\n\n        #print(targets, path)\n        return targets, path, deepest\n\n    def propagate(self, indexes: list, value: int = None):\n        tree, lazy, elem_size = self.tree, self.lazy, self.elem_size\n        if value is None:\n            for n in indexes:\n                if lazy[n] is None:\n                    continue\n                tree[n] = lazy[n]\n                if n < elem_size:\n                    lazy[n << 1] = lazy[(n << 1)+1] = lazy[n]\n                lazy[n] = None\n        else:\n            for n in indexes:\n                if n < elem_size:\n                    lazy[n << 1] = lazy[(n << 1)+1] = value\n                tree[n] = value\n                lazy[n] = None\n\n    def get_indexes_with_propagation(self, l: int, r: int, current_node: int, l_end: int, r_end: int):\n        # print(l,r,current_node,l_end,r_end,self.lazy[current_node])\n        indexes = []\n        tree, lazy = self.tree, self.lazy\n        lazy_value, lazy[current_node] = lazy[current_node], None\n        left_child, right_child = current_node << 1, (current_node << 1) + 1\n\n        if lazy_value is not None:\n            tree[current_node] = lazy_value\n            if left_child < self.tree_size:\n                lazy[left_child] = lazy[right_child] = lazy_value\n\n        if l == l_end and r == r_end:\n            return [current_node]\n\n        mid = (l_end + r_end) // 2\n\n        if l < mid:\n            l_r = r if r < mid else mid\n            indexes += self.get_indexes_with_propagation(l, l_r, left_child, l_end, mid)\n        if r > mid:\n            r_l = l if mid < l else mid\n            indexes += self.get_indexes_with_propagation(r_l, r, right_child, mid, r_end)\n\n        return indexes\n\n    def update_lazy(self, l, r, value):\n        '''\n        indexes = sorted(self.get_indexes_with_propagation(l, r, 1, 0, self.elem_size))\n        l = self.elem_size\n        lazy, tree, update = self.lazy, self.tree, self.update_tree\n        for n in indexes:\n            lazy[n] = None\n            if n < l:\n                lazy[n << 1] = value\n                lazy[(n << 1)+1] = value\n            tree[n] = value\n            update(n)\n        print(\"update_lazy\",indexes)\n        '''\n        targets, paths, deepest = self.get_indexes(l, r)\n        self.propagate(paths)\n        self.propagate(targets, value)\n        self.update_tree(deepest[0])\n        self.update_tree(deepest[1])\n\n    def get_value(self, l: int, r: int):\n        '''\n        tree = self.tree\n        indexes = self.get_indexes_with_propagation(l, r, 1, 0, self.elem_size)\n        update = self.update_tree\n        for n in indexes:\n            update(n)\n        '''\n        tree = self.tree\n        targets, paths, deepest = self.get_indexes(l, r)\n        self.propagate(paths)\n        self.propagate(targets)\n        self.update_tree(deepest[0])\n        self.update_tree(deepest[1])\n\n        # ===== change me =====\n        #print([(n,tree[n]) for n in indexes])\n        return min(tree[n] for n in targets)\n\n    def update_tree(self, k: int):\n        tree, lazy = self.tree, self.lazy\n        if k >= self.elem_size:\n            k >>= 1\n\n        while k > 0:\n            left, right = k << 1, (k << 1)+1\n            if lazy[k] is None:\n                if lazy[left] is not None:\n                    tree[left] = lazy[left]\n                if lazy[right] is not None:\n                    tree[right] = lazy[right]\n                tree[k] = tree[left] if tree[left] < tree[right] else tree[right]\n            else:\n                tree[left] = tree[right] = tree[k] = lazy[k]\n                lazy[left] = lazy[right] = lazy[k] = None\n            # ===== change me =====\n\n            k >>= 1\n\n    def set_value(self, i: int, value: int, op: str):\n        k = self.elem_size + i\n        if op == \"=\":\n            self.tree[k] = value\n        elif op == \"+\":\n            self.tree[k] += value\n        self.update_tree(k)\n\n\nn, q = map(int, input().split())\nrmq = SegmentTree([2**31-1]*n, 2**31-1)\nans = []\nappend = ans.append\nfor _ in [0]*q:\n    l = list(map(int, input().split()))\n    if l[0] == 0:\n        rmq.update_lazy(l[1], l[2]+1, l[3])\n        #print(rmq.get_indexes(l[1],l[2]+1))\n    else:\n        a = rmq.get_value(l[1], l[2]+1)\n        #print(rmq.get_indexes(l[1],l[2]+1))\n        append(a)\n    #print(rmq.tree,rmq.lazy)\n\nprint(\"\\n\".join([str(n) for n in ans]))",
        "language": "python"
      },
      "similarity": {
        "bleu": 0.5866863323301198,
        "jaccard": 0.8695652173913043,
        "tsed": 0.7932921447484546,
        "cged": 0.0,
        "codebleu": 0.6775319232272479
      }
    },
    {
      "case": "p02350",
      "src": {
        "code": "# https://onlinejudge.u-aizu.ac.jp/courses/library/3/DSL/all/DSL_2_F\n# \n\n\ndef _gidx(l, r, treesize):\n    '''\n    lazy propagationidx 1based-index.(-1)\n    [l,r)idxyield\n    treesizeself.num\n    '''\n    L, R = l + treesize, r + treesize\n    lm = (L // (L & -L)) >> 1  # \n    rm = (R // (R & -R)) >> 1\n    while L < R:\n        if R <= rm:\n            yield R\n        if L <= lm:\n            yield L\n        L >>= 1\n        R >>= 1\n    while L:  # R\n        yield L\n        L >>= 1\n\n\nclass SegmentTreeForRMQ:  # range minimum query\n    def __init__(self, ls: list, segfunc=min, identity_element=2**63, lazy_ide=None):\n        '''\n        \n        lsO(len(ls))\n        segfunc\n        identity elemente.g., inf, 0, 1, gcd0\n        [](https://ja.wikipedia.org/wiki/%E5%8D%98%E4%BD%8D%E5%85%83)\n        '''\n        self.ide = identity_element\n        self.lide = lazy_ide  # lazy\n        self.func = segfunc\n        n = len(ls)\n        self.num = 2 ** (n - 1).bit_length()  # n2\n        self.tree = [self.ide] * (2 * self.num)  # -1\n        self.lazy = [self.lide] * (2 * self.num)  # \n        for i, l in enumerate(ls):  # \n            self.tree[i + self.num - 1] = l\n        for i in range(self.num - 2, -1, -1):  # \n            self.tree[i] = segfunc(self.tree[2 * i + 1], self.tree[2 * i + 2])\n\n    def _lazyprop(self, *ids):\n        '''\n        \n        - self.tree[i]  self.lazy[i]\n        - self.lazy ****\n        - self.lazy[i]\n        '''\n        for i in reversed(ids):\n            i -= 1  # 0basedindex\n            v = self.lazy[i]\n            if v == self.lide:\n                continue  # NASA\n            # \n            # \n            # lazytree\n            self.tree[2 * i + 1] = v\n            self.tree[2 * i + 2] = v\n            self.lazy[2 * i + 1] = v\n            self.lazy[2 * i + 2] = v\n            self.lazy[i] = self.lide  # \n\n    def update(self, l, r, x):\n        '''\n        [l,r)x() O(logN)\n        '''\n        # 1, lazy(self.tree)\n        ids = tuple(_gidx(l, r, self.num))\n        self._lazyprop(*ids)\n        # 2, tree,lazy (treelazyprop)\n        if r <= l:\n            return ValueError('invalid index (l,r)')\n        l += self.num\n        r += self.num\n        while l < r:\n            if r & 1:\n                r -= 1  # \n                self.tree[r - 1] = x\n                self.lazy[r - 1] = x\n            if l & 1:\n                self.tree[l - 1] = x\n                self.tree[l - 1] = x  # \n                self.lazy[l - 1] = x  # lazy\n                l += 1\n            l >>= 1\n            r >>= 1\n        # 3, data\n        for i in ids:\n            i -= 1  # to 0based\n            self.tree[i] = self.func(\n                self.tree[2 * i + 1], self.tree[2 * i + 2])\n\n    def query(self, l, r):\n        '''\n        [l,r)O(logN)gcd\n        '''\n        if r <= l:\n            return ValueError('invalid index (l,r)')\n        # 1, lazy\n        self._lazyprop(*_gidx(l, r, self.num))\n        # 2, [l,r)\n        l += self.num\n        r += self.num\n        res = self.ide\n        while l < r:  # \n            if r & 1:\n                r -= 1\n                res = self.func(res, self.tree[r - 1])\n            if l & 1:\n                res = self.func(res, self.tree[l - 1])\n                l += 1\n            l >>= 1\n            r >>= 1  # \n        return res\n\n\nn, q = map(int, input().split())\nls = [2 ** 31 - 1] * n\nseg = SegmentTreeForRMQ(ls, identity_element=2**31 - 1)\n\nfor _ in range(q):\n    cmd, *tmp = map(int, input().split())\n    if cmd == 0:\n        s, t, x = tmp\n        seg.update(s, t + 1, x)\n    else:\n        s, t = tmp\n        print(seg.query(s, t + 1))\n\n",
        "language": "python"
      },
      "dst": {
        "code": "class SegmentTree(object):\n    INIT = 2 ** 31 - 1\n    DIVIDED = -1\n\n    def __init__(self, n: int) -> None:\n        size = 1\n        while size < n:\n            size *= 2\n        self.size = 2 * size - 1\n        self.data = [-1] * self.size\n        self.data[0] = self.INIT\n\n    def set_range(self, l: int, h: int, v: int) -> None:\n        def _set_range(r, i: int, j: int, vv: int) -> None:\n            if (j < l or i > h):\n                if vv != self.DIVIDED:\n                    self.data[r] = vv\n            elif (l <= i and j <= h):  # noqa: E741\n                self.data[r] = v\n            else:\n                if self.data[r] != self.DIVIDED:\n                    if vv == self.DIVIDED:\n                        vv = self.data[r]\n                    self.data[r] = self.DIVIDED\n                mid = i + (j - i) // 2\n                _set_range(r * 2 + 1, i, mid, vv)\n                _set_range(r * 2 + 2, mid + 1, j, vv)\n\n        _set_range(0, 0, self.size // 2, self.DIVIDED)\n\n    def min(self, i: int, j: int) -> int:\n        def _min(r, l: int, h: int) -> int:\n            if (j < l or i > h):\n                return self.INIT\n            elif self.data[r] != self.DIVIDED:\n                return self.data[r]\n            else:\n                mid = l + (h - l) // 2\n                return min(_min(r * 2 + 1, l, mid),\n                           _min(r * 2 + 2, mid + 1, h))\n\n        return _min(0, 0, self.size // 2)\n\n\nif __name__ == \"__main__\":\n    n, q = map(lambda x: int(x), input().split())\n    segtree = SegmentTree(n)\n\n    for _ in range(q):\n        com, *v = map(lambda x: int(x), input().split())\n        if (0 == com):\n            segtree.set_range(v[0], v[1], v[2])\n        else:\n            print(segtree.min(v[0], v[1]))\n\n",
        "language": "python"
      },
      "similarity": {
        "bleu": 0.10396211517947772,
        "jaccard": 0.21844660194174756,
        "tsed": 0.2679292929292926,
        "cged": 0.2357473035439137,
        "codebleu": 0.21205189522402357
      }
    },
    {
      "case": "1178_A",
      "src": {
        "code": "n=int(input())\nA=list(map(int,input().split()))\nSum=sum(A)//2\ncount=2\nAlice=A[0]\nTotal=A[0]\nAns=[1]\nBool=False\nfor val in A[1:]:\n    #print(Total,Sum)\n    if 2*val <= Alice:\n        Ans.append(count)\n        Total += val\n    if Total > Sum:\n        Bool=True\n        break\n    count += 1\nif Bool==True:\n    print(len(Ans))\n    print(*Ans)\nelse:\n    print(0)",
        "language": "python"
      },
      "dst": {
        "code": "def Input():\n    tem = input().split()\n    ans = []\n    for it in tem:\n        ans.append(int(it))\n    return ans\n\nn = Input()[0]\na = Input()\nans = [1]\ntotal = a[0]\nMax = sum(a)\nfor i in range(1,n):\n    if a[0]>=a[i]*2:\n        total+=a[i]\n        ans.append(i+1)\nif total>Max/2:\n    print(len(ans))\n    print(1,end='')\n    for i in range(1,len(ans)):\n        print('',ans[i],end=\"\")\n    print()\nelse:\n    print(0)",
        "language": "python"
      },
      "similarity": {
        "bleu": 0.19119060558515025,
        "jaccard": 0.5,
        "tsed": 0.42085889570552176,
        "cged": 0.5046153846153847,
        "codebleu": 0.1801219281999623
      }
    },
    {
      "case": "1178_A",
      "src": {
        "code": "n=int(input())\na=list(map(int,input().split()))\nsm=sum(a)\nb=[(a[i],i) for i in range(1,n)]\nb.sort()\nans=[1]\nx=a[0]\nfl=0\nfor i in b:\n    if x>sm/2:\n        fl=1\n        break\n    if a[0]>=2*i[0]:\n        ans.append(i[1]+1)\n        x+=i[0]\nif(fl):\n    print(len(ans))\n    print(*ans)\nelse:print(0)",
        "language": "python"
      },
      "dst": {
        "code": "n = int(input())\n\na = list(map(int, input().split()))\n\ns = a[0]\nns = [1]\nall_sum = a[0]\n\nfor i in range(1, n):\n    p = a[i]\n    all_sum += p\n    if 2*p <= a[0]:\n        s += p\n        ns.append(i+1)\n\nif 2*s > all_sum:\n    print(len(ns))\n    print(*ns)\nelse:\n    print(0)",
        "language": "python"
      },
      "similarity": {
        "bleu": 0.4458517341385322,
        "jaccard": 0.6818181818181818,
        "tsed": 0.582857142857143,
        "cged": 0.536723163841808,
        "codebleu": 0.32614290710921157
      }
    },
    {
      "case": "1178_A",
      "src": {
        "code": "n = int(input())\na = list(map(int, input().split()))\npartners = a[1:]\n\n# print(' '.join(map(str, a)))\n# print(' '.join(map(str, partners)))\n\nc = [1]\ntotal_sum = sum(a)\ncoal_size = a[0]\n\nfor i, p in enumerate(partners):\n    if 2 * coal_size > total_sum:\n        break\n    if a[0] >= 2 * p:\n        c.append(i + 2)\n        coal_size += p\n\nif 2 * coal_size <= total_sum:\n    c = []\n\nprint(len(c))\nif len(c) > 0:\n    print(' '.join(map(str, c)))\n",
        "language": "python"
      },
      "dst": {
        "code": "n = int(input())\n\nparties = [int(item) for item in input().split(' ')]\n\nalice = parties[0]\nindex = 2\n\nvotes = sum(parties)\nmajority = votes // 2\ncoalition = ['1']\nvotes = alice\nfor item in parties[1:]:\n    if votes > majority:\n        break\n    if item * 2 <= alice:\n        coalition.append(str(index))\n        votes += item\n    index += 1\n\nif votes > majority:\n    print(len(coalition))\n    print(\" \".join(coalition))\nelse:\n    print(\"0\")\n",
        "language": "python"
      },
      "similarity": {
        "bleu": 0.21799247055911203,
        "jaccard": 0.5714285714285714,
        "tsed": 0.5242857142857146,
        "cged": 0.5117493472584856,
        "codebleu": 0.25556666818940377
      }
    },
    {
      "case": "1178_A",
      "src": {
        "code": "# @oj: codeforces\n# @id: hitwanyang\n# @email: 296866643@qq.com\n# @date: 2020-10-10 10:39\n# @url:https://codeforc.es/contest/1178/problem/A\nimport sys,os\nfrom io import BytesIO, IOBase\nimport collections,itertools,bisect,heapq,math,string\nfrom decimal import *\n# region fastio\n\nBUFSIZE = 8192\n\nBUFSIZE = 8192\n\nclass FastIO(IOBase):\n    newlines = 0\n\n    def __init__(self, file):\n        self._fd = file.fileno()\n        self.buffer = BytesIO()\n        self.writable = \"x\" in file.mode or \"r\" not in file.mode\n        self.write = self.buffer.write if self.writable else None\n\n    def read(self):\n        while True:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            if not b:\n                break\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines = 0\n        return self.buffer.read()\n\n    def readline(self):\n        while self.newlines == 0:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            self.newlines = b.count(b\"\\n\") + (not b)\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines -= 1\n        return self.buffer.readline()\n\n    def flush(self):\n        if self.writable:\n            os.write(self._fd, self.buffer.getvalue())\n            self.buffer.truncate(0), self.buffer.seek(0)\n\n\nclass IOWrapper(IOBase):\n    def __init__(self, file):\n        self.buffer = FastIO(file)\n        self.flush = self.buffer.flush\n        self.writable = self.buffer.writable\n        self.write = lambda s: self.buffer.write(s.encode(\"ascii\"))\n        self.read = lambda: self.buffer.read().decode(\"ascii\")\n        self.readline = lambda: self.buffer.readline().decode(\"ascii\")\n\n\nsys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)\ninput = lambda: sys.stdin.readline().rstrip(\"\\r\\n\")\n# ------------------------------\n## !!!!!!\n## ,,!!!\n## ,,\ndef main():\n    n=int(input())\n    a=list(map(int,input().split()))\n    s=sum(a)\n    temp=[]\n    for i in range(2,n+1):\n        if a[i-1]<=a[0]//2:\n            temp.append((i,a[i-1]))\n    res=[1]\n    if a[0]+sum([x[1] for x in temp])<=s//2:\n        print (0)\n    else:\n        cnt=a[0]\n        for t in temp:\n            cnt=cnt+t[1]\n            if cnt>s//2:\n                res.append(t[0])\n                break\n            res.append(t[0])\n        print (len(res))\n        print (\" \".join([str(x) for x in res]))\nif __name__ == \"__main__\":\n    main()",
        "language": "python"
      },
      "dst": {
        "code": "def solve(n,a):\n    g=a[1:n];ind=[];tot=[a[0]]\n    for i in range(n-1):\n        if a[0]>=2*g[i]:ind.append(i+2);tot.append(g[i])\n    if sum(tot)>sum(a)//2:return [1]+ind\n    else:return [0]\nn=int(input());a=list(map(int,input().split()))\nif a[0]>sum(a)//2:print(1);print(1)\nelse:\n    p=solve(n,a)\n    if p==[0]:print(0)\n    else:print(len(p));print(*p)\n",
        "language": "python"
      },
      "similarity": {
        "bleu": 0.0959973096004648,
        "jaccard": 0.24647887323943662,
        "tsed": 0.16298421807747476,
        "cged": 0.3445121951219512,
        "codebleu": 0.24530245787782115
      }
    },
    {
      "case": "1178_A",
      "src": {
        "code": "n = int(input())\n\nparties = list(map(int, input().split(\" \")))\ntotal_deputies = sum(parties)\nmy_party = parties[0]\ncoallition_is = [1]\ntotal_coallition = 0\ntotal_against_us = 0\n\nfor i, party in enumerate(parties[1:]):\n    if my_party >= party*2:\n        coallition_is.append(i+2)\n        total_coallition += party\n    else:\n        total_against_us += party\n\nif my_party + total_coallition > total_against_us:\n    print(len(coallition_is))\n    print(\" \".join(map(str, coallition_is)))\nelse:\n    print(0)",
        "language": "python"
      },
      "dst": {
        "code": "x=int(input())\nm=list(map(int,input().split(' ')))\na=[m[0]]\nb=1\nfor i in range(1,x):\n    if 2*m[i]<=m[0]:\n        a.append(m[i])\n        b+=1\n    else:\n        a.append(0)\nif sum(a)>sum(m)//2:\n    print(b)\n    for j in range(len(a)):\n        if a[j]>0:\n            print(j+1,end=' ')\nelse:\n    print(0)\n    \n",
        "language": "python"
      },
      "similarity": {
        "bleu": 0.30114236677757916,
        "jaccard": 0.5833333333333334,
        "tsed": 0.5362318840579711,
        "cged": 0.5322997416020672,
        "codebleu": 0.2892956489296563
      }
    },
    {
      "case": "1178_A",
      "src": {
        "code": "N=int(input())\nl=list(map(int,input().split()))\ns=sum(l)\nif l[0]>s//2:\n    print(1)\n    print(1)\nelse:\n    k=[1]\n    d=l[0]\n    flag=0\n    for i in range(1,N):\n        if l[0]>=l[i]*2:\n            d+=l[i]\n            k.append(i+1)\n        if d>s//2:\n            flag=1\n            break\n    if flag==0:\n        print(0)\n    else:\n        print(len(k))\n        for i in k:\n            print(i,end=\" \")\n        print()\n",
        "language": "python"
      },
      "dst": {
        "code": "n = int(input())\na = input().split(' ')\n\nfor i in range(n):\n  a[i] = int(a[i])\n\nsum = a[0]\nres = [0]\n\nfor i in range(1, n):\n  if a[0] >= a[i]*2:\n    res.append(i)\n    sum += a[i]\n\nsumall = 0\nfor val in a:\n  sumall += val\n\nif sumall / 2 < sum:\n  print(len(res))\n  for i in range(len(res)):\n    print(res[i]+1, end=' ')\nelse:\n  print(0)\n",
        "language": "python"
      },
      "similarity": {
        "bleu": 0.35010986205014666,
        "jaccard": 0.6590909090909091,
        "tsed": 0.49419354838709684,
        "cged": 0.5069124423963134,
        "codebleu": 0.2541895747461091
      }
    },
    {
      "case": "1178_A",
      "src": {
        "code": "#JMD\n#Nagendra Jha-4096\n\n \nimport sys\nimport math\n\n#import fractions\n#import numpy\n \n###File Operations###\nfileoperation=0\nif(fileoperation):\n    orig_stdout = sys.stdout\n    orig_stdin = sys.stdin\n    inputfile = open('W:/Competitive Programming/input.txt', 'r')\n    outputfile = open('W:/Competitive Programming/output.txt', 'w')\n    sys.stdin = inputfile\n    sys.stdout = outputfile\n\n###Defines...###\nmod=1000000007\n \n###FUF's...###\ndef nospace(l):\n    ans=''.join(str(i) for i in l)\n    return ans\n \n \n \n##### Main ####\nt=1\nfor tt in range(t):\n    n=int(input())\n    #n,k,s= map(int, sys.stdin.readline().split(' '))\n    a=list(map(int,sys.stdin.readline().split(' ')))\n\n    ans= [1]\n    get=a[0]\n\n    for i in range(1,n):\n        if(2*a[i]<=a[0]):\n            ans.append(i+1)\n            get+=a[i]\n\n    tot=sum(a)\n\n    if get>tot-get:\n        print(len(ans))\n        print(*ans)\n    else:\n        print(0)\n    \n    \n#####File Operations#####\nif(fileoperation):\n    sys.stdout = orig_stdout\n    sys.stdin = orig_stdin\n    inputfile.close()\n    outputfile.close()",
        "language": "python"
      },
      "dst": {
        "code": "N = int(input())\nArr = list(map(int,input().split(\" \")))\nA=Arr.copy()\nMaxSeats = sum(Arr)\nMajority = 1+(MaxSeats//2)\nTTT = Arr[0]\nInd = [1]\nSum = Arr[0]\nArr[0]=-1\nwhile(Sum<Majority):\n\tM = max(Arr)\n\tI=Arr.index(M)\n\tif(M==-1):\n\t\tbreak\n\tif(TTT>=2*M):\n\t\tInd.append(I+1)\n\t\tSum+=M\n\tArr[I]=-1\n\nif(Sum<Majority):\n\tprint(0)\nelse:\n\tprint(len(Ind))\n\tprint(*Ind)",
        "language": "python"
      },
      "similarity": {
        "bleu": 0.14558270829705153,
        "jaccard": 0.2916666666666667,
        "tsed": 0.2918918918918921,
        "cged": 0.3702127659574468,
        "codebleu": 0.1971321954345535
      }
    },
    {
      "case": "1178_A",
      "src": {
        "code": "n = int(input())\na = list(map(int, input().split()))\nx, t, c = a[0], sum(a), [1]\ny = x\nfor i in range(1, n):\n    if x >= 2*a[i]:\n        c.append(i+1)\n        y += a[i]\nif y > t//2:\n    print(len(c))\n    for i in c:\n        print(i, end=\" \")\nelse:\n    print(0)",
        "language": "python"
      },
      "dst": {
        "code": "n = int(input())\na = list(map(int,input().split()))\nl = []\nfor i in range(n):\n    if(a[0]>=2*a[i]):\n        l.append([i+1,a[i]])\n\nk = sum(a)\np = 0\nfor i in range(len(l)):\n    p+=l[i][1]\np+=a[0]\nif(p>=k//2+1):\n    l.append([1,a[0]])\n    print(len(l))\n    for i in range(len(l)):\n        print(l[i][0],end = ' ')\nelse:\n    print(0)\n",
        "language": "python"
      },
      "similarity": {
        "bleu": 0.385306186560383,
        "jaccard": 0.825,
        "tsed": 0.5748427672955975,
        "cged": 0.6472019464720195,
        "codebleu": 0.34276227512104396
      }
    },
    {
      "case": "1178_A",
      "src": {
        "code": "n = int(input())\narray = list(map(int, input().split()))\nsm = sum(array)\nx = 1\narx = [1]\nsm -= array[0]\ngm = array[0]\nfor i in range(1, n):\n    if array[i] * 2 <= array[0]:\n        arx.append(i+1)\n        sm -= array[i]\n        gm += array[i]\n        x += 1\nif gm > sm:\n    print(x)\n    print(*arx)\nelse:\n    print(0)",
        "language": "python"
      },
      "dst": {
        "code": "n = int(input())\na = [int(i) for i in input().split()]\nparlament_count = sum(a)\ncoalence_ind = [1]\ncoalence_sum = a[0]\nif a[0] >= parlament_count//2 + 1:\n    print(1)\n    print(1)\nelse:\n    for i in range(1, len(a)):\n        if a[0] >= 2*a[i]:\n            coalence_sum += a[i]\n            coalence_ind.append(i + 1)\n    if coalence_sum >= parlament_count // 2 + 1:\n        print(len(coalence_ind))\n        print(*coalence_ind)\n    else:\n        print(0)",
        "language": "python"
      },
      "similarity": {
        "bleu": 0.336797239668986,
        "jaccard": 0.6428571428571429,
        "tsed": 0.614814814814815,
        "cged": 0.5068119891008174,
        "codebleu": 0.28357490517425304
      }
    },
    {
      "case": "1178_A",
      "src": {
        "code": "from math import *\nn=int(input())\narr=list(map(int,input().split()))\narr1=[]\nfor i in range(1,n):\n\tarr1.append((arr[i],i))\nsumx=sum(arr)\narr1.sort()\nans=arr[0]\nansarr=[1]\nfor i in range(len(arr1)):\n\tif(2*arr1[i][0]>arr[0]):\n\t\tbreak\n\telse:\n\t\tans+=arr1[i][0]\n\t\tansarr.append(arr1[i][1]+1)\nlimit=sumx//2+1\nif(ans<limit):\n\tprint(0)\nelse:\n\tprint(len(ansarr))\n\tprint(*ansarr)\n\n",
        "language": "python"
      },
      "dst": {
        "code": "n=int(input())\nli=list(map(int,input().split()))\nsu=li[0]\nsu2=li[0]\ncom=li[0]\nans=list()\nans.append(0)\nfor i in range(1,len(li)):\n    quo=li[0]//li[i]\n    if quo>=2:\n        su=su+li[i]\n        ans.append(i)\n    su2=su2+li[i]\nqu=su2//su\nif qu<2:\n    print(len(ans))\n    for b in ans:\n        print(b+1,end=' ')\n    print()\nelse:\n    print(0)\n    \n        \n",
        "language": "python"
      },
      "similarity": {
        "bleu": 0.3375369538869679,
        "jaccard": 0.6078431372549019,
        "tsed": 0.4322981366459628,
        "cged": 0.569377990430622,
        "codebleu": 0.2680648447929712
      }
    },
    {
      "case": "13_A",
      "src": {
        "code": "def sumInBase(num, base):\n    ans = 0\n    while num != 0:\n        ans += num % base\n        num //= base\n\n    return ans\n\n\ndef GCD(a, b):\n    if b == 0:\n        return a\n    return GCD(b, a % b)\n\n\nA = int(input())\nsum = 0\nfor i in range(2, A):\n    sum += sumInBase(A, i)\n\nt = GCD(sum, A - 2)\n\nprint('{}/{}'.format(sum // t, (A - 2) // t))\n",
        "language": "python"
      },
      "dst": {
        "code": "def gcd(a, b):\n    if b == 0:\n        return a\n    return gcd(min(a,b), max(a, b) % min(a,b))\nval = int(input())\nz = 0\nfor i in range(2, val):\n    w = val\n    x = 0\n    while w:\n        x += int(w % i)\n        w = int(w / i)\n    z += x\ngcf = gcd(z, val - 2)\nprint(\"{}/{}\".format(z // gcf, (val - 2) // gcf))",
        "language": "python"
      },
      "similarity": {
        "bleu": 0.40359821516393823,
        "jaccard": 0.6222222222222222,
        "tsed": 0.5579831932773108,
        "cged": 0.5043478260869565,
        "codebleu": 0.3954385617378572
      }
    },
    {
      "case": "13_A",
      "src": {
        "code": "#               5    2\ndef sumInBase(num, base):\n    ans = 0\n    while num != 0:\n        ans += num % base\n        num //= base\n    return ans\n\n\ndef gcd(a, b):\n    if a == 0:\n        return b\n    return gcd(b % a, a)\n\n\nA = int(input())\nans, sumOfAll = 0, 0\nfor i in range(2, A):\n    sumOfAll += sumInBase(A, i)\ntemp = gcd(sumOfAll, A - 2)\nprint('{}/{}'.format(sumOfAll // temp, (A - 2) // temp))\n",
        "language": "python"
      },
      "dst": {
        "code": "import copy\nfrom fractions import Fraction\n\n\ndef convert_base(number, base):\n\tc_num = int(number)\n\tdigits = []\n\twhile c_num:\n\t\tdigits.append(c_num%base)\n\t\tc_num //= base\n\treturn digits\n\ndef sum_of_digits(numbers):\n\td_sum = 0\n\tfor number in numbers:\n\t\td_sum += number\n\treturn d_sum\n\t\ndef sum_all(number):\n\tbase = 2\n\ttotal = 0\n\twhile base != number:\n\t\ttotal += sum_of_digits(convert_base(number, base))\n\t\tbase += 1\n\treturn total\n\t\n\nnumber = int(input())\n\ntotal = sum_all(number)\n# make rational format\nrational = Fraction(total,number-2)\n\nif total%(number-2)!=0:\n\tprint(rational)\nelse:\n\tprint(\"{}/1\".format(rational))\n",
        "language": "python"
      },
      "similarity": {
        "bleu": 0.17028301312711255,
        "jaccard": 0.45,
        "tsed": 0.4722580645161294,
        "cged": 0.4136125654450262,
        "codebleu": 0.2010330372262862
      }
    },
    {
      "case": "13_A",
      "src": {
        "code": "import math\n\n\ndef sumInBase(num, base):\n    ans = 0\n    while num != 0:\n        ans += num % base\n        num //= base\n    return ans\n\n\nA = int(input())\nsumofAll = 0\nfor i in range(2, A):\n    sumofAll += sumInBase(A, i)\ntemp = math.gcd(sumofAll, A - 2)\nprint('{}/{}'.format(sumofAll // temp, (A - 2) // temp))\n",
        "language": "python"
      },
      "dst": {
        "code": "def gcd(a, b):\n    if a > b:\n        return gcd(b, a)\n    elif b % a == 0:\n        return a\n    else:\n        return gcd(b % a, a)\n\ndef base_sum(n, a):\n    if n < a:\n        return n\n    else:\n        return base_sum(n // a, a) + n % a\n\nA = int(input())\ns = sum([base_sum(A, i) for i in range(2, A)])\nx = gcd(s, A - 2)\nprint('{}/{}'.format(s//x, (A - 2)//x))\n\n\n",
        "language": "python"
      },
      "similarity": {
        "bleu": 0.30277396272281804,
        "jaccard": 0.52,
        "tsed": 0.5268292682926836,
        "cged": 0.5427728613569321,
        "codebleu": 0.24394458867862995
      }
    },
    {
      "case": "13_A",
      "src": {
        "code": "class Number:\n\tdef main(self):\n\t    sum=0\n\t    sums=0\n\t    n=int(input())\n\t    for i in range(2,n):\n\t        s=n\n\t        while(s>0):\n\t            sum=sum+(s%i)\n\t            s=int(s/i)\n\t    sums=sums+sum\n\t    b=n-2\n\t    a=sums\n\t    #For HCF\n\t    if a<b:\n\t        x=b\n\t        b=a\n\t        a=x\n\t    while (a%b!=0):\n\t        d=a%b\n\t        a=b\n\t        b=d\n\t        \n\t    hcf=b\n\t    d1=sums/hcf\n\t    d2=(n-2)/hcf\n\t    print(\"%d/%d\"%(d1,d2))\n    \nob=Number()\nob.main()\n",
        "language": "python"
      },
      "dst": {
        "code": "n = int(input())\ns = 0\nfor i in range(2,n):\n    p=n\n    while p>0:\n        s+=(p%i)\n        p=p//i\na=s\nb=n-2\nwhile b>0:\n    pom=b\n    b=a%b\n    a=pom\nprint(str(s//a)+\"/\"+str((n-2)//a))",
        "language": "python"
      },
      "similarity": {
        "bleu": 0.2682503828134607,
        "jaccard": 0.5106382978723404,
        "tsed": 0.42236024844720516,
        "cged": 0.3141993957703928,
        "codebleu": 0.3144166504044905
      }
    },
    {
      "case": "13_A",
      "src": {
        "code": "from fractions import gcd\ndef base(n,x):\n    s=0\n    while x//n!=0:\n        s+=x%n\n        x//=n\n    s+=x%n\n    return s\nn=int(input())\nnb=0\nfor i in range(2,n):\n    nb+=base(i,n)\ng=gcd(nb,n-2)\nprint(str(nb//g)+'/'+str((n-2)//g))",
        "language": "python"
      },
      "dst": {
        "code": "n = int(input())\ns = 0\nfor i in range(2,n):\n    p=n\n    while p>0:\n        s+=(p%i)\n        p=p//i\na=s\nb=n-2\nwhile b>0:\n    pom=b\n    b=a%b\n    a=pom\nprint(str(s//a)+\"/\"+str((n-2)//a))",
        "language": "python"
      },
      "similarity": {
        "bleu": 0.38730940386552953,
        "jaccard": 0.5789473684210527,
        "tsed": 0.5219047619047621,
        "cged": 0.5724137931034483,
        "codebleu": 0.28563891552248455
      }
    },
    {
      "case": "13_A",
      "src": {
        "code": "from math import gcd\n\ndef base(n , b):\n    c = 0\n    while n:\n        c += n%b\n        n //= b\n    return c\n\n\n\nn = int(input())\nx = 0\n\nfor i in range(2 , int(n)):\n    x += base(int(n) , i)\n\n\nn -= 2\nhcf = gcd(x , n)\n\n\nx //= hcf\nn //= hcf\nprint(f\"{x}/{n}\")\n\n",
        "language": "python"
      },
      "dst": {
        "code": "import math; a = int(input());sum = 0\nfor i in range(2, a):\n    t = a\n    while t != 0:\n        sum += t%i;t //= i\nd = math.gcd(sum, a-2)\nprint(str(sum//d)+'/'+str((a-2)//d))",
        "language": "python"
      },
      "similarity": {
        "bleu": 0.20569741659721993,
        "jaccard": 0.5238095238095238,
        "tsed": 0.29591836734693877,
        "cged": 0.45669291338582674,
        "codebleu": 0.283730153622301
      }
    },
    {
      "case": "13_A",
      "src": {
        "code": "from math import gcd\nn,s=int(input()),0\nfor i in range(2,n):\n  k=n\n  while k!=0:\n    s+=k%i\n    k//=i\np=gcd(s,n-2)\nprint(s//p,\"/\",(n-2)//p,sep=\"\")",
        "language": "python"
      },
      "dst": {
        "code": "\n\ndef convert_base(number, base):\n    if base < 2:\n        return False\n    remainders = []\n    while number > 0:\n        remainders.append(int(number % base))\n        number //= base\n    return sum(remainders)\n\ni = 2\nres = 0\nnum = int(input())\ngd = num-2\nwhile i != num:\n    res += convert_base(num, i)\n    i += 1\n\n\nfor i in range(2, res):\n    while res % i == 0 and gd%i ==0 :\n        res /= i\n        gd /= i\nprint('%d/%d' %(res,gd))\n",
        "language": "python"
      },
      "similarity": {
        "bleu": 0.12314308251139118,
        "jaccard": 0.4,
        "tsed": 0.3824000000000006,
        "cged": 0.43365695792880254,
        "codebleu": 0.13350439981241669
      }
    },
    {
      "case": "13_A",
      "src": {
        "code": "import math\nn=int(input())\nsum=0\nfor i in range(2,n):\n  a=n\n  while(a>0):\n    sum+=a%i\n    a//=i\nx=math.gcd(sum,n-2)    \nif(x!=1):\n  print(str(sum//x)+'/'+str((n-2)//x))\nelse:   \n  print(str(sum)+'/'+str(n-2))\n",
        "language": "python"
      },
      "dst": {
        "code": "x=int(input())\ns=0\nfor i in range(2,x):\n    j=0\n    y=x\n    while y!=0:\n        s+=(y%i)\n        y=y//i\ny=(x-2)\n#print(x,i)\nfor j in range(x-2,1,-1):\n    if s%j==0 and y%j==0:\n        s=s//j \n        y=y//j\n        #print(i)\nprint(s,end='')\nprint('/',end='')\nprint(y)\n        ",
        "language": "python"
      },
      "similarity": {
        "bleu": 0.18604292340325607,
        "jaccard": 0.5897435897435898,
        "tsed": 0.41147540983606573,
        "cged": 0.4084084084084084,
        "codebleu": 0.1932428833355283
      }
    },
    {
      "case": "13_A",
      "src": {
        "code": "import sys\nimport math\n\ndef gcd(a, b):\n    if(b == 0):\n        return a\n    r = a % b\n    return gcd(b, r)\n\nA = int(sys.stdin.readline())\n\nres = 0\nfor i in range(2, A):\n    k = A\n    while(k > 0):\n        res += k % i\n        k = int(k / i)\n    \nt = gcd(res, A - 2)\nprint(str(int(res / t)) + \"/\" + str(int((A - 2) / t)))\n",
        "language": "python"
      },
      "dst": {
        "code": "def gcd(a, b):\n    if b == 0:\n        return a\n    return gcd(min(a,b), max(a, b) % min(a,b))\nval = int(input())\nz = 0\nfor i in range(2, val):\n    w = val\n    x = 0\n    while w:\n        x += int(w % i)\n        w = int(w / i)\n    z += x\ngcf = gcd(z, val - 2)\nprint(\"{}/{}\".format(z // gcf, (val - 2) // gcf))",
        "language": "python"
      },
      "similarity": {
        "bleu": 0.2938284372773052,
        "jaccard": 0.5208333333333334,
        "tsed": 0.6064516129032258,
        "cged": 0.5683060109289617,
        "codebleu": 0.31464971566533656
      }
    },
    {
      "case": "13_A",
      "src": {
        "code": "import math\nn= int(input())\njam = 0\nl = 0\ng = 0\nfor i in range(2, n) :\n    l=n\n    while (l != 0) :\n        jam = jam + (l%i)\n        l//=i\ng=math.gcd(jam,n-2)\nprint(f\"{jam//g}/{(n-2)//g}\")\n",
        "language": "python"
      },
      "dst": {
        "code": "def gcd(a,b):\n    if b==0:return a\n    return gcd(b,a%b)\nn=int(input())\ntemp,s,cf=0,0,0\nfor i in range(2,n):\n    temp=n \n    while(temp):\n        s+=temp%i \n        temp=temp//i \ncf=gcd(s,n-2)\nprint(str(s//cf)+\"/\"+str((n-2)//cf))",
        "language": "python"
      },
      "similarity": {
        "bleu": 0.31809145593479127,
        "jaccard": 0.525,
        "tsed": 0.5500000000000005,
        "cged": 0.49070631970260226,
        "codebleu": 0.17036423456805583
      }
    },
    {
      "case": "p00158",
      "src": {
        "code": "while True:\n    n = int(input());\n    if n == 0:\n        break;\n    i = 0;\n    while n != 1:\n        i += 1;\n        if n % 2 == 0:\n            n = n / 2;\n        else:\n            n = n * 3 + 1;\n    print(i);\n",
        "language": "python"
      },
      "dst": {
        "code": "while True:\n    n = int(input())\n    if n==0: break\n    count = 0\n    while True:\n        if n==1:\n            print(count)\n            break\n        elif n % 2 ==0:\n            n /= 2\n            count +=1\n        else:\n            n*=3\n            n+=1\n            count += 1\n",
        "language": "python"
      },
      "similarity": {
        "bleu": 0.45757856614651327,
        "jaccard": 0.8076923076923077,
        "tsed": 0.5696969696969696,
        "cged": 0.6176470588235294,
        "codebleu": 0.3748487428768329
      }
    },
    {
      "case": "p00158",
      "src": {
        "code": "def korat(x):\n    i = 0\n    while x > 1:\n        if x % 2:\n            x = x * 3 + 1\n            i += 1\n        while x % 2 == 0:\n            x = x // 2\n            i += 1\n    return i\n\nwhile True:\n    n = int(input())\n    if n == 0:\n        break\n    print(korat(n))\n",
        "language": "python"
      },
      "dst": {
        "code": "while True :\n    n = int(input())\n    \n    if n == 0 :\n        break\n    else :\n        cnt = 0\n        \n        while True:\n            if n == 1 :\n                print(cnt)\n                break\n            \n            elif n % 2 == 0 :\n                n /= 2\n                cnt += 1\n                \n            else :\n                n *= 3\n                n += 1\n                cnt += 1\n        \n\n",
        "language": "python"
      },
      "similarity": {
        "bleu": 0.3851198687341022,
        "jaccard": 0.6896551724137931,
        "tsed": 0.293506493506494,
        "cged": 0.46451612903225803,
        "codebleu": 0.28520091434553013
      }
    },
    {
      "case": "p00158",
      "src": {
        "code": "while True:\n    n = int(input())\n    if n == 0:\n        break\n    \n    ans = 0    \n    while n != 1:\n        \n        if n % 2 == 0:\n            n = n/2\n        else:\n            n = n*3+1\n        \n        ans += 1\n    \n    print(ans)\n",
        "language": "python"
      },
      "dst": {
        "code": "for i in range(50):\n    n = int(input())\n    \n    if n == 0:    break\n    \n    i = 0\n    while 1:\n        if n == 1:  break\n        if n % 2 == 0:\n            n = n / 2\n        else:\n            n = n*3 + 1\n        i += 1\n    \n    print(i)\n",
        "language": "python"
      },
      "similarity": {
        "bleu": 0.6555880094156613,
        "jaccard": 0.7142857142857143,
        "tsed": 0.8647058823529411,
        "cged": 0.6705202312138728,
        "codebleu": 0.4730096095301433
      }
    },
    {
      "case": "p00158",
      "src": {
        "code": "while True:\n    n = int(input())\n    count = 0\n    if n == 0:\n        break\n    \n    while True:\n        if n == 1:\n            break\n        elif n % 2 == 0:\n            n = n / 2\n            count += 1\n        else:\n            n = n * 3 + 1\n            count += 1\n    print(count)\n",
        "language": "python"
      },
      "dst": {
        "code": "# coding: utf-8\n# Your code here!\n\nwhile True:\n   n = int(input())\n   if n == 0: break\n   \n   c = 0\n   while n != 1:\n      if n % 2 == 0:\n         n /= 2\n      else:\n         n = n * 3 + 1\n      c += 1\n   print(c)\n",
        "language": "python"
      },
      "similarity": {
        "bleu": 0.5545850126030067,
        "jaccard": 0.6363636363636364,
        "tsed": 0.6176470588235293,
        "cged": 0.7571428571428571,
        "codebleu": 0.6053029461286937
      }
    },
    {
      "case": "p00158",
      "src": {
        "code": "def collatz(n):\n    if n % 2 == 0:\n        return n // 2\n    else:\n        return n * 3 +1\nwhile True:\n    n = int(input())\n    if n == 0:\n        break\n    a = 0\n    while n != 1:\n        n = collatz(n)\n        a += 1\n    print(a)\n",
        "language": "python"
      },
      "dst": {
        "code": "while True:\n    n = int(input())\n    if n==0: break\n    count = 0\n    while n!=1:\n        n = n//2 if n%2==0 else 3*n+1\n        count += 1\n    print(count)",
        "language": "python"
      },
      "similarity": {
        "bleu": 0.5663912281408232,
        "jaccard": 0.8148148148148148,
        "tsed": 0.5,
        "cged": 0.7483870967741936,
        "codebleu": 0.3383392781805759
      }
    },
    {
      "case": "p00158",
      "src": {
        "code": "while True:\n  n =int(input())\n  if n==0:\n    break\n  num=0\n  while n!=1:\n    if n%2==0:\n      n=n/2\n      num+=1\n    else:\n      n=n*3+1\n      num+=1\n      \n  print(num)\n      \n",
        "language": "python"
      },
      "dst": {
        "code": "def co(x):\n    m = 0\n    while True:\n        if x==1:\n            break\n        if x%2==0:\n            x = x//2\n            m+=1\n        else:\n            x = int(x*3+1)\n            m+=1\n    print(m)\nwhile True:\n    n = int(input())\n    if n==0:\n        break\n    co(n)\n",
        "language": "python"
      },
      "similarity": {
        "bleu": 0.42832973620820686,
        "jaccard": 0.7777777777777778,
        "tsed": 0.4962962962962962,
        "cged": 0.5185185185185186,
        "codebleu": 0.25113983662535055
      }
    },
    {
      "case": "p00158",
      "src": {
        "code": "#0\n#if\n#\n\nwhile True:\n    n = int(input())\n    count = 0\n    if n == 0:\n        break\n    while n != 1:\n        if n%2 == 0:\n            n = n/2\n            count += 1\n        else:\n            n = n * 3 + 1\n            count += 1\n    print(count)\n\n",
        "language": "python"
      },
      "dst": {
        "code": "#0\nwhile True:\n    num = int(input())\n    if num == 0:break\n\n#num2231\n    else:\n        kei = 0\n        while num != 1:\n            if num % 2 == 0:num /= 2\n            else:\n                num *= 3\n                num += 1\n            kei += 1\n        print(kei)\n",
        "language": "python"
      },
      "similarity": {
        "bleu": 0.3707930664557174,
        "jaccard": 0.6666666666666666,
        "tsed": 0.6119402985074627,
        "cged": 0.7205882352941176,
        "codebleu": 0.3752305435887995
      }
    },
    {
      "case": "p00158",
      "src": {
        "code": "while True:\n    n = int(input())\n    i = 0\n    if n == 0:\n        break\n    while True:\n        if n == 1:\n            break\n        if n % 2 == 0:\n            n = n // 2\n            i = i + 1\n        elif n % 2 != 0:\n            n = n * 3 + 1\n            i = i + 1\n    print(i)\n\n",
        "language": "python"
      },
      "dst": {
        "code": "#81 \n\nwhile 1:\n    n = int(input())\n    if n == 0:\n        break\n    \n    ans = 0\n    while n != 1:\n        if n%2 == 0:\n            n = n//2\n            ans += 1\n        else:\n            n = n*3+1\n            ans += 1\n    print(ans)\n",
        "language": "python"
      },
      "similarity": {
        "bleu": 0.5168070585765662,
        "jaccard": 0.7142857142857143,
        "tsed": 0.6779220779220778,
        "cged": 0.7215189873417722,
        "codebleu": 0.49056988255646683
      }
    },
    {
      "case": "p00158",
      "src": {
        "code": "while True:\n    n = int(input())\n    if n==0:\n        break\n    m = 0\n    while True:\n        if n==1:\n            break\n        if n % 2==0:\n            n = n / 2\n            m += 1\n        else:\n            n = n * 3 + 1\n            m += 1\n    print(m)\n",
        "language": "python"
      },
      "dst": {
        "code": "while True :\n    n = int(input())\n    \n    if n == 0 :\n        break\n    else :\n        cnt = 0\n        \n        while True:\n            if n == 1 :\n                print(cnt)\n                break\n            \n            elif n % 2 == 0 :\n                n /= 2\n                cnt += 1\n                \n            else :\n                n *= 3\n                n += 1\n                cnt += 1\n        \n\n",
        "language": "python"
      },
      "similarity": {
        "bleu": 0.6301195020752542,
        "jaccard": 0.875,
        "tsed": 0.6411764705882352,
        "cged": 0.7299270072992701,
        "codebleu": 0.38692239890075886
      }
    },
    {
      "case": "p00158",
      "src": {
        "code": "# coding: utf-8\n# Your code here!\n\n\n    \ndef coll(n):    \n    k=0\n    while n>1:\n        if n%2:\n            n=n*3+1\n            k+=1\n        while n%2==0:\n            n=n//2\n            k+=1\n    return k\n    \nwhile True:\n    n=int(input())\n    if n==0:\n        break\n    print(coll(n))\n",
        "language": "python"
      },
      "dst": {
        "code": "while True:\n    a = int(input())\n    if a == 0:\n        break\n    c = 0\n    \n    while a != 1:\n        c += 1\n        if a %2:\n            a = 3 * a +1\n        else:\n            a = a//2\n    print(c)\n            \n",
        "language": "python"
      },
      "similarity": {
        "bleu": 0.21322589506480116,
        "jaccard": 0.5405405405405406,
        "tsed": 0.28101265822784843,
        "cged": 0.46451612903225803,
        "codebleu": 0.23763310918848954
      }
    },
    {
      "case": "p03128",
      "src": {
        "code": "N, M = map(int, input().split())\nA = list(reversed(sorted(map(int, input().split()))))\nc = [2,5,5,4,5,6,3,7,6]\nx = [0]*(N+1)\nfor i in range(1,N+1):\n    x[i] = max([-1]+[x[i-c[a-1]]+1 for a in A if i >= c[a-1]])\nn = N\nfor _ in range(N):\n    for a in A:\n        if n >= c[a-1] and x[n-c[a-1]] == x[n]-1:\n            print(a, end=\"\")\n            n -= c[a-1]\n            break\nprint(\"\")",
        "language": "python"
      },
      "dst": {
        "code": "N,M=map(int,input().split())\nA=list(map(int,input().split()))\nweight=[0,2,5,5,4,5,6,3,7,6] # \ndp=[-1]*(N+1) # i\ndp[0]=0\nfor i in range(N+1):\n    for a in A:\n        if i+weight[a]<N+1: # N\n            dp[i+weight[a]]=max(dp[i+weight[a]],dp[i]*10+a) # a\nprint(dp[N]) # N",
        "language": "python"
      },
      "similarity": {
        "bleu": 0.43675300491051783,
        "jaccard": 0.6363636363636364,
        "tsed": 0.4977011494252874,
        "cged": 0.49443207126948774,
        "codebleu": 0.31399742230888567
      }
    },
    {
      "case": "p03128",
      "src": {
        "code": "n, m = map(int, input().split())\na = list(map(int, input().split()))\nl = [0, 2, 5, 5, 4, 5, 6, 3, 7, 6]\ndp = [-1] * (n+1)\ndp[0] =  0\n\nfor i in range(n+1):\n    for j in a:\n        if i + l[j] < n+1:\n            dp[i + l[j]] = max(dp[i + l[j]], dp[i]*10 + j)\nprint(dp[-1])",
        "language": "python"
      },
      "dst": {
        "code": "N,M = map(int,input().split())\nA = list(map(int,input().split()))\nc=[2,5,5,4,5,6,3,7,6]\n\ndp = [-1 for _ in range(N+1)]\ndp[0] = 0\n\nfor i in range(N+1):\n    for a in A:\n        if i-c[a-1]>=0:\n            dp[i] = max(dp[i], dp[i-c[a-1]]*10 + a)\n\nprint(dp[-1])\n",
        "language": "python"
      },
      "similarity": {
        "bleu": 0.6386901630067525,
        "jaccard": 0.7555555555555555,
        "tsed": 0.8081300813008131,
        "cged": 0.6591549295774648,
        "codebleu": 0.35690213697326884
      }
    },
    {
      "case": "p03128",
      "src": {
        "code": "N, M = map(int,input().split())\nA = list(map(int, input().split()))\ncost = [2,5,5,4,5,6,3,7,6]\n\ndp = [-1 for _ in [0]*(N+10)]\ndp[0] = 0\n\nfor i in range(N+1):\n    for a in A:\n        if i-cost[a-1] < 0 or dp[i-cost[a-1]] < 0:\n            continue\n        if dp[i-cost[a-1]]*10 + a > dp[i]:\n            dp[i] = dp[i-cost[a-1]]*10 + a\nprint(dp[N])",
        "language": "python"
      },
      "dst": {
        "code": "n, m = map(int, input().split()) \na = list(map(int, input().split()))\nb = [0, 2, 5, 5, 4, 5, 6, 3, 7, 6]\n\ndp = [-1] * (n + 1)\ndp[n] = 0\n\nfor i in range(n, -1, -1):\n    for j in range(m):\n        x = b[a[j]]\n        if dp[i] != -1 and i - x >= 0:\n            dp[i - x] = max(dp[i - x], 10 * dp[i] + a[j])\n            \nprint(dp[0])",
        "language": "python"
      },
      "similarity": {
        "bleu": 0.49906831288011544,
        "jaccard": 0.68,
        "tsed": 0.6120805369127518,
        "cged": 0.5784313725490196,
        "codebleu": 0.2903378602313803
      }
    },
    {
      "case": "p03128",
      "src": {
        "code": "\nN, M = map(int, input().split())\nX = list(map(int, input().split()))\n\nX.sort(reverse=True)\nnum = [0, 2, 5, 5, 4, 5, 6, 3, 7, 6]\ndp = [-1] * (N + 1)\ndp[0] = 0\n\nfor a in X:\n    for i in range(N + 1):\n        if dp[i] == -1 or i + num[a] > N:\n            continue\n        dp[i + num[a]] = max(dp[i + num[a]], dp[i] * 10 + a)\n\nprint(dp[-1])\n",
        "language": "python"
      },
      "dst": {
        "code": "n, m = map(int, input().split())\na = list(map(int, input().split()))\n\nmatch = [0, 2, 5, 5, 4, 5, 6, 3, 7, 6]\nd = dict()\nfor e in a:\n    d[e] = match[e]\n\ndp = [-1] * (n + 1)\ndp[0] = 0\nfor i in range(1, n + 1):\n    for k, v in d.items():\n        if i - v >= 0 and dp[i-v] != -1:\n            dp[i] = max(dp[i], dp[i-v] * 10 + k)\n\nprint(dp[n])\n",
        "language": "python"
      },
      "similarity": {
        "bleu": 0.575512612669426,
        "jaccard": 0.6363636363636364,
        "tsed": 0.6191780821917812,
        "cged": 0.5685785536159601,
        "codebleu": 0.4542387097446451
      }
    },
    {
      "case": "p03128",
      "src": {
        "code": "#https://atcoder.jp/contests/abc118/submissions/4292288\nn,m = map(int, input().split())\nb = [0,2,5,5,4,5,6,3,7,6]\na = [0]+list(map(int, input().split()))\nf = [-1]*(n+1)\nf[0]=0\nfor i in range(1,n+1):\n    for j in range(1,m+1):\n        x = a[j]\n        if(i-b[x]<0):\n            continue\n        f[i] = max(f[i],f[i-b[x]]*10 + x)\n        #print(i+1,\",\",str(f[i])+\",\"+str(f[i-b[x]]*10 + x),\"\",f)\nprint(f[n])",
        "language": "python"
      },
      "dst": {
        "code": "n,m,*a=map(int,open(0).read().split())\nc=(0,2,5,5,4,5,6,3,7,6)\nd=[0]*n*9\nfor i in range(n):\n for j in a:\n  if d[i]or i<1:d[i+c[j]]=max(d[i+c[j]],d[i]*10+j)\nprint(d[n])",
        "language": "python"
      },
      "similarity": {
        "bleu": 0.26163155634267543,
        "jaccard": 0.5666666666666667,
        "tsed": 0.4764705882352942,
        "cged": 0.5882352941176471,
        "codebleu": 0.23121840185738074
      }
    },
    {
      "case": "p03128",
      "src": {
        "code": "def main():\n    N, M, *A = map(int, open(0).read().split())\n\n    C = [0, 1, 4, 4, 3, 4, 5, 2, 6, 5]\n\n    dp = [0] * N + [-1] * 6\n    for i in range(N):\n        dp[i + 1] = max(dp[i - C[a]] * 10 + a for a in A)\n\n    print(dp[N])\n\nif __name__ == '__main__':\n    main()",
        "language": "python"
      },
      "dst": {
        "code": "N, M, *A = map(int, open(0).read().split())\n\nC = [0, 1, 4, 4, 3, 4, 5, 2, 6, 5]\n\ndp = [0] * N + [-1] * 9\nfor i in range(N):\n    dp[i + 1] = max(a + 10 * dp[i - C[a]] for a in A)\n\nprint(dp[N])\n",
        "language": "python"
      },
      "similarity": {
        "bleu": 0.8036290192515526,
        "jaccard": 0.8571428571428571,
        "tsed": 0.8133333333333334,
        "cged": 0.6140845070422536,
        "codebleu": 0.6865159449949044
      }
    },
    {
      "case": "p03128",
      "src": {
        "code": "N, M = map(int, input().split())\nA = [int(a) for a in input().split()]\nL = [0, 2, 5, 5, 4, 5, 6, 3, 7, 6]\nA.sort(reverse = True)\n#print(A)\ndp = [0] + ([-1]*N)\n#print(dp)\nfor i in range(1, N+1):\n    for a in A:\n        if L[a] <= i:\n            dp[i] = max(dp[i], dp[i-L[a]] * 10 + a)\n#print(dp)\nprint(dp[-1])\n",
        "language": "python"
      },
      "dst": {
        "code": "n, m=map(int, input().split())\na=list(map(int, input().split()))\nd={1:2, 2:5, 3:5, 4:4, 5:5, 6:6, 7:3, 8:7, 9:6}\nmemo=[0]*(n+1)\nmemo[0]=0\nmemo[1]=-10**10\nfor i in range(2, n+1):\n    res=-10**10\n    for ai in a:\n        if d[ai]>i:\n            continue\n        res=max(res, ai+memo[i-d[ai]]*10)\n    memo[i]=res\nprint(memo[n])\n",
        "language": "python"
      },
      "similarity": {
        "bleu": 0.27436880336636077,
        "jaccard": 0.5818181818181818,
        "tsed": 0.5720000000000001,
        "cged": 0.5635910224438903,
        "codebleu": 0.21036663998486366
      }
    },
    {
      "case": "p03128",
      "src": {
        "code": "n, m = map(int, input().strip().split())\na = list(map(int, input().strip().split()))\n\ndp = [None] * (n+1)\ndp[0] = 0\nx = (0,2,5,5,4,5,6,3,7,6)\nfor i in range(2, n+1):\n    for v in a:\n        if i-x[v] >= 0 and dp[i-x[v]] != None:\n            if not dp[i]:\n                dp[i] = dp[i-x[v]]*10+v\n            else:\n                dp[i] = max(dp[i], dp[i-x[v]]*10+v)\n\nprint(dp[n])\n",
        "language": "python"
      },
      "dst": {
        "code": "def inpl(): return list(map(int, input().split()))\n\nN, M = inpl()\nA = inpl()\nA.sort(reverse = True)\n\nmatch = (0, 2, 5, 5, 4, 5, 6, 3, 7, 6)\ndp = [0]+[-float('inf')]*N\n\nfor i in range(1, N+1):\n    dp[i] = max([10*dp[max(-1,i-match[a])] + a for a in A])\n\nprint(''.join(sorted(str(dp[-1]), reverse = True)))\n",
        "language": "python"
      },
      "similarity": {
        "bleu": 0.3418106834399953,
        "jaccard": 0.55,
        "tsed": 0.2746835443037976,
        "cged": 0.5,
        "codebleu": 0.19705421430820047
      }
    },
    {
      "case": "p03128",
      "src": {
        "code": "n,m,*a=map(int,open(0).read().split())\nd=[0]+[-1]*n*9\nfor i in range(n):d[i+1]=max(j+d[i-int('0144345265'[j])]*10 for j in a)\nprint(d[n])",
        "language": "python"
      },
      "dst": {
        "code": "N,M=[int(x) for x in input().split()]\nX=[0,2,5,5,4,5,6,3,7,6]\n#    1,2,3,4,5,6,7,8,9\n\nA=[int(x) for x in input().split()]\n\n\n\nANS=[0]\nfor i in range(1,N+1):\n\tans=0\n\tfor j in A:\n\t\tif i==X[j]:\n\t\t\tans=max(j,ans)\n\t\telif i>=X[j]:\n\t\t\ttemp=ANS[i-X[j]]\n\t\t\tif temp!=0:\n\n\t\t\t\tans=max(ans,10*temp+j)\n\t\t\n\t\t#print(ans)\n\tANS.append(ans)\nprint(ANS[-1])\n\t\n",
        "language": "python"
      },
      "similarity": {
        "bleu": 0.08974627502444703,
        "jaccard": 0.4444444444444444,
        "tsed": 0.3357142857142863,
        "cged": 0.47867298578199047,
        "codebleu": 0.10503136104989705
      }
    },
    {
      "case": "p03128",
      "src": {
        "code": "# coding: utf-8\n\nimport sys\ninput = sys.stdin.readline\n\nN, M = map(int, input().split())\nA = list(map(int, input().split()))\n\nneed = [0,2,5,5,4,5,6,3,7,6]\n\ndp = [-1] * (N + 1)\ndp[0] = 0\n\nfor i in range(N + 1):\n        for a in A:\n                if i + need[a] <= N:\n                        dp[i + need[a]] = max(dp[i + need[a]], dp[i] * 10 + a)\n\nprint(dp[-1])\n\n",
        "language": "python"
      },
      "dst": {
        "code": "n,m=map(int,input().split())\na=list(map(int,input().split()))\ndp=[0]*(n+9)\nd=[0,2,5,5,4,5,6,3,7,6]\nfor i in range(n+1):\n  for j in a:\n    if dp[i]or i<1:dp[i+d[j]]=max(dp[i+d[j]],dp[i]*10+j)\nprint(dp[n])",
        "language": "python"
      },
      "similarity": {
        "bleu": 0.5498916051826439,
        "jaccard": 0.6415094339622641,
        "tsed": 0.6857142857142857,
        "cged": 0.636085626911315,
        "codebleu": 0.32611838016353994
      }
    },
    {
      "case": "p03992",
      "src": {
        "code": "# code-festival-2016-quala\ndef main():\n    S = input().rstrip()\n    ans = S[:4] + \" \" + S[4:]\n    print(ans)\n\n\nif __name__ == \"__main__\":\n    main()",
        "language": "python"
      },
      "dst": {
        "code": "S = input()\nprint(S[:4] + ' ' + S[4:])",
        "language": "python"
      },
      "similarity": {
        "bleu": 0.30799825232596834,
        "jaccard": 0.44,
        "tsed": 0.444,
        "cged": 0.4736842105263158,
        "codebleu": 0.233319778240632
      }
    },
    {
      "case": "p03992",
      "src": {
        "code": "S=input()\nfor i in range(4):\n  print(S[i],end=\"\")\nprint(\" \",end=\"\")\nfor i in range(8):\n  print(S[i+4],end=\"\")\nprint()",
        "language": "python"
      },
      "dst": {
        "code": "s=input()\nx=s[:4]\ny=s[4:]\nprint(x+\" \"+y)",
        "language": "python"
      },
      "similarity": {
        "bleu": 0.0725492997989058,
        "jaccard": 0.47619047619047616,
        "tsed": 0.29374999999999996,
        "cged": 0.3089430894308943,
        "codebleu": 0.1907894736842105
      }
    },
    {
      "case": "p03992",
      "src": {
        "code": "s=input()\nfor i in range(4):\n    print(s[i],end=\"\")\nprint(\" \",end=\"\")\nfor i in range(8):\n    print(s[i+4],end=\"\")\nprint(\"\")",
        "language": "python"
      },
      "dst": {
        "code": "l = input().strip()\nprint(l[:4] + \" \" + l[4:])\n",
        "language": "python"
      },
      "similarity": {
        "bleu": 0.08733494456810412,
        "jaccard": 0.47619047619047616,
        "tsed": 0.1462686567164181,
        "cged": 0.272,
        "codebleu": 0.20555555555555555
      }
    },
    {
      "case": "p03992",
      "src": {
        "code": "# code festival A\ns = input()\nprint(s[:4] + ' ' +  s[4:])\n",
        "language": "python"
      },
      "dst": {
        "code": "s = input()\nprint(s[:4], end=\"\")\nprint(\" \", end=\"\")\nprint(s[4:])\n",
        "language": "python"
      },
      "similarity": {
        "bleu": 0.5139922356116855,
        "jaccard": 0.5882352941176471,
        "tsed": 0.44390243902439014,
        "cged": 0.7142857142857143,
        "codebleu": 0.25783242104800796
      }
    },
    {
      "case": "p03992",
      "src": {
        "code": "# li = list(map(int, input().split()))\ns = input()\nprint(s[:4]+' '+s[4:])",
        "language": "python"
      },
      "dst": {
        "code": "s = input()\nprint(\"{0} {1}\".format(s[:4], s[4:]))",
        "language": "python"
      },
      "similarity": {
        "bleu": 0.4070190836305988,
        "jaccard": 0.5,
        "tsed": 0.5629629629629629,
        "cged": 0.6909090909090909,
        "codebleu": 0.46725169444371656
      }
    },
    {
      "case": "p03992",
      "src": {
        "code": "s = input()\nt = s[:4] + ' ' + s[4:]\nprint(t)",
        "language": "python"
      },
      "dst": {
        "code": "s = input()\nfor i in range(12):\n\tif i == 4:\n\t\tprint('', s[i], end = '')\n\telse:\n\t\tprint(s[i], end = '')\nprint()",
        "language": "python"
      },
      "similarity": {
        "bleu": 0.09702113941873192,
        "jaccard": 0.47619047619047616,
        "tsed": 0.3807692307692306,
        "cged": 0.33684210526315794,
        "codebleu": 0.22020187157658538
      }
    },
    {
      "case": "p03992",
      "src": {
        "code": "s=input()\nprint(s[:4] + \" \" + s[4:])",
        "language": "python"
      },
      "dst": {
        "code": "S = input()\nprint(S[0:4]+' '+S[4:])",
        "language": "python"
      },
      "similarity": {
        "bleu": 0.5744888426961038,
        "jaccard": 0.7692307692307693,
        "tsed": 0.9692307692307692,
        "cged": 1.0,
        "codebleu": 0.3666666666666667
      }
    },
    {
      "case": "p03992",
      "src": {
        "code": "a = input()\na = u'{0}'.format(a)\nprint('{0} {1}'.format(a[:4],a[4:]))",
        "language": "python"
      },
      "dst": {
        "code": "d=input()\nprint(d[:4]+\" \"+d[4:])\n",
        "language": "python"
      },
      "similarity": {
        "bleu": 0.22637483204056413,
        "jaccard": 0.45,
        "tsed": 0.40512820512820513,
        "cged": 0.5625,
        "codebleu": 0.4
      }
    },
    {
      "case": "p03992",
      "src": {
        "code": "a=input()\nprint(a[:4]+' '+ a[4:])",
        "language": "python"
      },
      "dst": {
        "code": "i=input()\nprint(i[:4]+\" \"+i[4:])",
        "language": "python"
      },
      "similarity": {
        "bleu": 0.6514613449066712,
        "jaccard": 0.8333333333333334,
        "tsed": 1.0,
        "cged": 1.0,
        "codebleu": 0.5
      }
    },
    {
      "case": "p03992",
      "src": {
        "code": "a = input()\nprint(a[:4] + \" \" + a[4:])",
        "language": "python"
      },
      "dst": {
        "code": "def main():\n    s=input()\n    print(s[0:4],s[4:],sep=' ')\n\nmain()\n",
        "language": "python"
      },
      "similarity": {
        "bleu": 0.25152091355775263,
        "jaccard": 0.5294117647058824,
        "tsed": 0.47058823529411753,
        "cged": 0.5263157894736843,
        "codebleu": 0.15416666666666667
      }
    }
  ],
  "total_processed_cases": 10,
  "total_processed_pairs": 100
}